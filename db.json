{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"source/log.svg","path":"log.svg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-async/source/failure.ico","path":"failure.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/sw.js","path":"sw.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/css/index.less","path":"css/index.less","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/img/banner.png","path":"img/banner.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/img/block.jpg","path":"img/block.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/css/plugins/bootstrap.min.css","path":"css/plugins/bootstrap.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/css/plugins/bootstrap.row.css","path":"css/plugins/bootstrap.row.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/css/plugins/font-awesome.min.css","path":"css/plugins/font-awesome.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/css/plugins/locomotive-scroll.css","path":"css/plugins/locomotive-scroll.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/fonts/webfonts/fa-brands-400.woff2","path":"fonts/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/fonts/webfonts/fa-regular-400.woff2","path":"fonts/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/fonts/webfonts/fa-solid-900.woff2","path":"fonts/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/js/plugins/local_search.js","path":"js/plugins/local_search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-async/source/js/plugins/typing.js","path":"js/plugins/typing.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"5fb49eabdf6597879de1a4bfc81eb8957d8a74e8","modified":1742809168760},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"9a94875cbf4c27fbe2e63da0496242addc6d2876","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1682003237818},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1682003237818},{"_id":"public/2023/04/20/hello-world/index.html","hash":"d521f2b66b8aba4b1a0688644b12c7c1864fa052","modified":1682155522854},{"_id":"public/archives/index.html","hash":"536b136d8cf21cf41a8bbdead1792ade3822e7f5","modified":1745830107884},{"_id":"public/archives/2023/index.html","hash":"2fcc17f8f74594a75523f6e915dfb6ab5abc2c01","modified":1682155700584},{"_id":"public/archives/2023/04/index.html","hash":"911d3b4dfbc2abd1b04b7a4e6f99a8e2982b944e","modified":1682155700584},{"_id":"public/index.html","hash":"6107a1b5461d647084f9ba202716bab2e466e121","modified":1745830107884},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1682003684231},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1682003684231},{"_id":"public/css/style.css","hash":"4da345d832a2682bcaee3ab3e22c15e3cd0e9cde","modified":1682003684231},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1682003684231},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1682003684231},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1682003684231},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1682003684231},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1682003684231},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1682003684231},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1682003684231},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1682003684231},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1682003684231},{"_id":"source/log.svg","hash":"007ce717bd046aa1c558dc09b32619832e7bea4d","modified":1682155590241},{"_id":"source/_data/languages.yml","hash":"228357903ce3df2bf7fd8055dbc09338ea49bf04","modified":1682004353542},{"_id":"node_modules/hexo-theme-async/README.md","hash":"42ce794d377d34a33e4d61384cb732d8306d8108","modified":1682003818587},{"_id":"node_modules/hexo-theme-async/README_zh-CN.md","hash":"f9dfc82d4b0e70f7afdbca600553157d5d7ebb47","modified":1682003818586},{"_id":"node_modules/hexo-theme-async/package.json","hash":"90194023c1cc6bbc54219d5c5a65c60d6219f2ae","modified":1682003818555},{"_id":"node_modules/hexo-theme-async/plugins.yml","hash":"f8eb3c9743d93c92816f05bc24e8140c04e52ee3","modified":1682003819985},{"_id":"node_modules/hexo-theme-async/_config.yml","hash":"954f17a561d063990911055974f1117c90287cff","modified":1682003819983},{"_id":"node_modules/hexo-theme-async/languages/zh-Hans.yml","hash":"78a0aa3ccf5ee05083a60070ca7a2b0946f62d8c","modified":1682003819985},{"_id":"node_modules/hexo-theme-async/languages/en.yml","hash":"71768276c06ffa953dc2dbb30e05df6a7a6bcec1","modified":1682003819983},{"_id":"node_modules/hexo-theme-async/layout/about.ejs","hash":"52c1091fb0a3bd123ca72ad341ba5d1531e794c0","modified":1682003818080},{"_id":"node_modules/hexo-theme-async/layout/comment.ejs","hash":"55d3a6b69c5fdbeb6e946541401528243b4455cb","modified":1682003818085},{"_id":"node_modules/hexo-theme-async/layout/404.ejs","hash":"711cf5844e92ce42c22f93b50c6b794f1104a39e","modified":1682003818078},{"_id":"node_modules/hexo-theme-async/layout/category.ejs","hash":"ba64e50a822c14ea64706ef147fbd735a093ee82","modified":1682003818084},{"_id":"node_modules/hexo-theme-async/layout/archive.ejs","hash":"699b18d557708ddbce89ec9fb3c2ffd8896f330b","modified":1682003818081},{"_id":"node_modules/hexo-theme-async/layout/custom.ejs","hash":"3e1cea3e7904992bdc8df2d630d75479bb2f6c16","modified":1682003818086},{"_id":"node_modules/hexo-theme-async/layout/index.ejs","hash":"02a02f3a2f5a9da329cd4c2ec0bd1af6c8d58f95","modified":1682003818094},{"_id":"node_modules/hexo-theme-async/layout/page.ejs","hash":"1a81e2a16d463f5f944ae3b79f444c2ac4de1ce0","modified":1682003818096},{"_id":"node_modules/hexo-theme-async/layout/links.ejs","hash":"5db12fd2559da0fdebf6c80566adbbf459361e61","modified":1682003818095},{"_id":"node_modules/hexo-theme-async/layout/layout.ejs","hash":"efaa02767b0b400376a2feba1ec910b972a327a3","modified":1682003818094},{"_id":"node_modules/hexo-theme-async/scripts/utils.js","hash":"fcde4a1eb77de269bcfee9135e77f171077d53ec","modified":1682003818552},{"_id":"node_modules/hexo-theme-async/layout/post.ejs","hash":"73264aa0e34b3cda21ec6ca33e932144c6b33811","modified":1682003818099},{"_id":"node_modules/hexo-theme-async/layout/project.ejs","hash":"379a9822df4eba98d3be636e76dc2c578cb47d47","modified":1682003818100},{"_id":"node_modules/hexo-theme-async/layout/_third-party/sw.ejs","hash":"277f75522dffa7d985f3400f18b4f60861d2430d","modified":1682003818101},{"_id":"node_modules/hexo-theme-async/source/sw.js","hash":"01b07120762ab155c99478afb36075d4d7e2bc9c","modified":1682003818549},{"_id":"node_modules/hexo-theme-async/layout/_third-party/web-analytics.ejs","hash":"9ed8b2717075bb8f37d65580f1de586ebbb89bc1","modified":1682003818104},{"_id":"node_modules/hexo-theme-async/layout/tag.ejs","hash":"9971000a24ac3bd1fdee7cd4a46ce1ccd1c48c5c","modified":1682003818102},{"_id":"node_modules/hexo-theme-async/layout/_third-party/plugin.ejs","hash":"1af7dac0d91366cc334be40aa78dec0c9a59158c","modified":1682003818096},{"_id":"node_modules/hexo-theme-async/layout/_third-party/cdn.ejs","hash":"964693a454808aa8277027ec3c5dda7f7af01255","modified":1682003818084},{"_id":"node_modules/hexo-theme-async/source/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1682003818325},{"_id":"node_modules/hexo-theme-async/layout/_partial/banner.ejs","hash":"4e3ce9dbbd00e0649ed352bf89c324b4023ad23b","modified":1682003818083},{"_id":"node_modules/hexo-theme-async/layout/_partial/header.ejs","hash":"891be309ffcc21616f3c00690407fda625bb18ff","modified":1682003818092},{"_id":"node_modules/hexo-theme-async/layout/_partial/footer.ejs","hash":"63a418de42c4ac263d5fba7388f7852bd84560c6","modified":1682003818090},{"_id":"node_modules/hexo-theme-async/layout/_partial/main.ejs","hash":"b96fbd7b839cb4f774cf332a7dd3ec4f3bd7bbb0","modified":1682003818096},{"_id":"node_modules/hexo-theme-async/layout/_partial/head.ejs","hash":"492db41c5ad4b5574385fc3924ec27b9633f5f15","modified":1682003818090},{"_id":"node_modules/hexo-theme-async/layout/_partial/script.ejs","hash":"6d9d5202a0eb36783505e77498ff54f85896f07e","modified":1682003818100},{"_id":"node_modules/hexo-theme-async/layout/_widget/header_menu.ejs","hash":"c2efd3f4417b8f6f27caf86a8467903d73fcdc6d","modified":1682003818091},{"_id":"node_modules/hexo-theme-async/layout/_widget/categorie.ejs","hash":"634d10e2965f9b2cdd662eaaf8ee027814eb7ad1","modified":1682003818084},{"_id":"node_modules/hexo-theme-async/layout/_widget/header_logo.ejs","hash":"6606af77338567179413b1596b558e77bde7c6bf","modified":1682003818091},{"_id":"node_modules/hexo-theme-async/layout/_widget/header_search.ejs","hash":"62a5a69f6206c224f037229968b2961f241eef2e","modified":1682003818092},{"_id":"node_modules/hexo-theme-async/scripts/console/plugin.js","hash":"d31a3bc8ee816dbccbf4da914116a9991dd0b395","modified":1682003818548},{"_id":"node_modules/hexo-theme-async/layout/_widget/fixed-btn.ejs","hash":"76b2e9fb70272e7fb2759ca58c0f76715fa5acce","modified":1682003818087},{"_id":"node_modules/hexo-theme-async/layout/_widget/header_theme.ejs","hash":"02e74ddaa74422e7189d219c1b360cb58cdd3e1a","modified":1682003818092},{"_id":"node_modules/hexo-theme-async/scripts/events/config.js","hash":"c0cafdbf5ad59d277065b22958026f004c00195d","modified":1682003818541},{"_id":"node_modules/hexo-theme-async/scripts/helper/index.js","hash":"bde383f098d69571eec6feca1539040ce132b820","modified":1682003818544},{"_id":"node_modules/hexo-theme-async/scripts/events/index.js","hash":"872489c688bdad9d3c70c3b8b73fcad55a5e38b8","modified":1682003818544},{"_id":"node_modules/hexo-theme-async/scripts/events/layout.js","hash":"ca81e8ed0aff086eca498c0bdc84ee05585ae245","modified":1682003818544},{"_id":"node_modules/hexo-theme-async/scripts/helper/async_config.js","hash":"2714e1f35aa5a625b27332898209c477e107b1c8","modified":1682003818539},{"_id":"node_modules/hexo-theme-async/layout/_widget/search.ejs","hash":"573c500a4ecb65b822b3a34168dbcf446c92bc0f","modified":1682003818101},{"_id":"node_modules/hexo-theme-async/scripts/helper/list_categories.js","hash":"57bcd21f608fd985a4c755a30e6b40ad91494f3e","modified":1682003818545},{"_id":"node_modules/hexo-theme-async/scripts/helper/list_archives.js","hash":"bfe4d871ca685d67cba73d824a3bbb8f610929b1","modified":1682003818545},{"_id":"node_modules/hexo-theme-async/scripts/helper/variable.js","hash":"3a39eb9b05b4624d444fbf036597932e3f8d7728","modified":1682003818555},{"_id":"node_modules/hexo-theme-async/scripts/helper/tag.js","hash":"0d9d369f95bdf916628132c7ca2452da63825741","modified":1682003818551},{"_id":"node_modules/hexo-theme-async/layout/_widget/paginator.ejs","hash":"c7b76e443375b7d2bb15452b34ffcc654105db1f","modified":1682003818096},{"_id":"node_modules/hexo-theme-async/scripts/helper/toc.js","hash":"b2bb8f1c854a5bb9cb6a0cb82de1cab7e5ba681b","modified":1682003818551},{"_id":"node_modules/hexo-theme-async/scripts/tags/caniuse.js","hash":"ce50e901dfe8b556786c1ebde4639d632e88c9ea","modified":1682003818540},{"_id":"node_modules/hexo-theme-async/scripts/tags/flink.js","hash":"b48daa4a9b70f616e7867b41badde830176f7e31","modified":1682003818541},{"_id":"node_modules/hexo-theme-async/scripts/tags/imgs.js","hash":"611ea3c68d2ea8dfc5711b77b42183f65c0e0296","modified":1682003818543},{"_id":"node_modules/hexo-theme-async/scripts/filters/cdn.js","hash":"ebc35d0ca20d65e7f113371ae3ddb0fd4988dee4","modified":1682003818540},{"_id":"node_modules/hexo-theme-async/scripts/tags/tabs.js","hash":"2ff28bdaf5bf184208290be766e98ed18ca84780","modified":1682003818550},{"_id":"node_modules/hexo-theme-async/scripts/filters/index.js","hash":"b1ea8e2b4b6ad798a5774a8633e55ca352ece5ae","modified":1682003818544},{"_id":"node_modules/hexo-theme-async/scripts/tags/gallery.js","hash":"81a6604d847199f12af569ebd512f1989c9660cb","modified":1682003818541},{"_id":"node_modules/hexo-theme-async/source/css/index.less","hash":"dfb6f56f06f8980a7c11962a92ba389f4d017dd3","modified":1682003818575},{"_id":"node_modules/hexo-theme-async/source/img/block.jpg","hash":"1dd350354bd3fe2e7287dfe063d7783e4ab91090","modified":1682003818537},{"_id":"node_modules/hexo-theme-async/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1682003818332},{"_id":"node_modules/hexo-theme-async/source/img/avatar.jpg","hash":"e9e4108ab199202288ee68342a40064649c3d7c1","modified":1682003818532},{"_id":"node_modules/hexo-theme-async/layout/_third-party/comment/giscus.ejs","hash":"7ce3479ece958b829a8b9a2256f0db53ce1eeac8","modified":1682003818090},{"_id":"node_modules/hexo-theme-async/source/js/main.js","hash":"ffb319279f80567f25383a01099b40ac81b0ff4f","modified":1682003818547},{"_id":"node_modules/hexo-theme-async/source/img/favicon.svg","hash":"ef922eea66dc950fb1327dd4571d777b8aeb8161","modified":1682003819696},{"_id":"node_modules/hexo-theme-async/layout/_third-party/comment/index.ejs","hash":"bac629e4c8d28cc16720c17d526e0b9fc7059be3","modified":1682003818093},{"_id":"node_modules/hexo-theme-async/layout/_third-party/comment/b-comments.ejs","hash":"202aace17a9bd66cf82b15cdd52db4d8a5b04d28","modified":1682003818081},{"_id":"node_modules/hexo-theme-async/layout/_third-party/seo/baidu-push.ejs","hash":"2e3d405b5973c5ceed9cc24a5591240c0345cb94","modified":1682003818082},{"_id":"node_modules/hexo-theme-async/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1682003818324},{"_id":"node_modules/hexo-theme-async/layout/_partial/page/archive.ejs","hash":"cf3ebc04bf199bcf4b396f55c7270c81363f2698","modified":1682003818081},{"_id":"node_modules/hexo-theme-async/layout/_third-party/comment/twikoo.ejs","hash":"d8c022399cc7e4a48ea01276641388dde925aa5d","modified":1682003818103},{"_id":"node_modules/hexo-theme-async/layout/_partial/page/about.ejs","hash":"78347fd6281147e49e3183ef30eda1e2105bf5e5","modified":1682003818079},{"_id":"node_modules/hexo-theme-async/layout/_partial/page/category.ejs","hash":"041a18d4d563349c0e3110f822d5e82ef6dc2c1a","modified":1682003818084},{"_id":"node_modules/hexo-theme-async/layout/_partial/page/index.ejs","hash":"19d539a157993bd92ec61db15cf4f6c8fefbbe11","modified":1682003818092},{"_id":"node_modules/hexo-theme-async/layout/_partial/page/links.ejs","hash":"c2ca0956b0ecb638c4ec7f69a498775ae21f6109","modified":1682003818095},{"_id":"node_modules/hexo-theme-async/layout/_partial/page/project.ejs","hash":"5e143fa68e889c6e829d12f5a89b2d8979a32e46","modified":1682003818099},{"_id":"node_modules/hexo-theme-async/layout/_partial/page/post.ejs","hash":"b55db31dacc274339a1b20a6659fb85bf884ea3a","modified":1682003818099},{"_id":"node_modules/hexo-theme-async/layout/_partial/page/tag.ejs","hash":"7f278f929ff15d2ae843c8931dcd00cbf273cf59","modified":1682003818102},{"_id":"node_modules/hexo-theme-async/layout/_partial/post/post-card.ejs","hash":"09e3037a9f67e47ddcd4c26d3f3b0dbdd0ef489b","modified":1682003818098},{"_id":"node_modules/hexo-theme-async/layout/_partial/post/post-copyright.ejs","hash":"b7e4518edcdc719795c30ad325c410a49255471a","modified":1682003818098},{"_id":"node_modules/hexo-theme-async/layout/_partial/post/post-card-mini.ejs","hash":"170f8d60eb92e857520ad31ef8fa6f317c3b5170","modified":1682003818097},{"_id":"node_modules/hexo-theme-async/layout/_partial/post/post-content.ejs","hash":"2cb43a1657dfcff799f67d8e06c31d4c9b571bca","modified":1682003818098},{"_id":"node_modules/hexo-theme-async/layout/_partial/post/post-next-prev.ejs","hash":"cbd221f3b36f652c80b3c0b0a14125243a13dd7c","modified":1682003818099},{"_id":"node_modules/hexo-theme-async/layout/_partial/post/post-info.ejs","hash":"980872eb767d5015f5bec52617cb74bdbcfbd976","modified":1682003818099},{"_id":"node_modules/hexo-theme-async/layout/_partial/post/reward.ejs","hash":"664c43ab7346d700d942e30d2a5bdd119743c647","modified":1682003818100},{"_id":"node_modules/hexo-theme-async/layout/_partial/preloader/change-mode-preloader.ejs","hash":"8a6019defee71021eb9bd46549c8a4479546ec9d","modified":1682003818085},{"_id":"node_modules/hexo-theme-async/layout/_partial/preloader/page-preloader.ejs","hash":"a1ce51be9b477e146dcc3bb4fbe9628c1471969e","modified":1682003818096},{"_id":"node_modules/hexo-theme-async/layout/_partial/sidebar/index.ejs","hash":"d94eefe8acb426c455bafea6be27a7fce6f4e127","modified":1682003818093},{"_id":"node_modules/hexo-theme-async/source/css/_components/app-frame.less","hash":"8fc482822be50c6dd5fccd85a2f9b8f6ef9d3423","modified":1682003818556},{"_id":"node_modules/hexo-theme-async/source/css/_components/base.less","hash":"4a5e380607970db240dbb8e3c404eef2cb80905e","modified":1682003818556},{"_id":"node_modules/hexo-theme-async/source/css/_components/blockquote.less","hash":"969d13d3e270b98287cfb1fc6ff0ca70dde480cc","modified":1682003818559},{"_id":"node_modules/hexo-theme-async/source/css/_components/banner.less","hash":"49be916c438e02e1a0430843e0cba704abb920e9","modified":1682003818556},{"_id":"node_modules/hexo-theme-async/source/css/_components/form.less","hash":"8bcd9e7d094a7ddfcd617bed07da8f2ca1db93e9","modified":1682003818567},{"_id":"node_modules/hexo-theme-async/source/css/_components/btn.less","hash":"4c1983d0899d133cff50c14f84cf5f834bb2c33c","modified":1682003818559},{"_id":"node_modules/hexo-theme-async/source/css/_components/card.less","hash":"7646cc3e11debfbf3d5186fa8470c88c0a6672dc","modified":1682003818560},{"_id":"node_modules/hexo-theme-async/source/css/_components/index.less","hash":"9b29da29f4a5a737b61d1ef3b10ad56257f7806d","modified":1682003818567},{"_id":"node_modules/hexo-theme-async/source/css/_components/fixed-btn.less","hash":"d7c75938b04ed376a98b69156d2d3753f182edbc","modified":1682003818566},{"_id":"node_modules/hexo-theme-async/source/css/_components/footer.less","hash":"148b39349030a2c400887adc972594cf788b69eb","modified":1682003818566},{"_id":"node_modules/hexo-theme-async/source/css/_components/list.less","hash":"a28990af7f211d3c919fad8e4dbe45af77d3c97f","modified":1682003818576},{"_id":"node_modules/hexo-theme-async/source/css/_components/menu.less","hash":"9aee9cd92fb77e90a47c522e5a3504eb49b62a4e","modified":1682003818577},{"_id":"node_modules/hexo-theme-async/source/css/_components/mode-switcher.less","hash":"c232eee8a2b4f3b9f74e8664a8074c06d542e7c9","modified":1682003818578},{"_id":"node_modules/hexo-theme-async/source/css/_components/message.less","hash":"e70983c10167cc08e7ea168d836b0788ac0edc5e","modified":1682003818577},{"_id":"node_modules/hexo-theme-async/source/css/_components/pagination.less","hash":"c9fd513fe0b88bde7bed61d3125da0c89b2da70b","modified":1682003818578},{"_id":"node_modules/hexo-theme-async/source/css/_components/preloader.less","hash":"01799e25f1f46adf890415b9ffa54d6faa8d6cf0","modified":1682003818578},{"_id":"node_modules/hexo-theme-async/source/css/_components/timeline.less","hash":"6f97e97a214172402ea5a4547d6f71825424a5af","modified":1682003818582},{"_id":"node_modules/hexo-theme-async/source/css/_components/tag-plugins.less","hash":"18f2265b80a57b722cf55180e93487d47af3e1ba","modified":1682003818582},{"_id":"node_modules/hexo-theme-async/source/css/_components/title-divider.less","hash":"762448f365a4ff121f0cc0ede58b773916d4e9ee","modified":1682003818583},{"_id":"node_modules/hexo-theme-async/source/css/_components/publication.less","hash":"c78e60be25b4c4253a53e6f7b395089e4419d141","modified":1682003818580},{"_id":"node_modules/hexo-theme-async/source/css/_components/top-bar.less","hash":"9f221a72f9d1aa62bb84e253fa1530aecf17deb6","modified":1682003818584},{"_id":"node_modules/hexo-theme-async/source/css/_components/toc.less","hash":"c0dc5ad1b20054bf9243a2befc13c9f53734a02a","modified":1682003818583},{"_id":"node_modules/hexo-theme-async/source/css/_components/video.less","hash":"862f3404abca726d1de29fbfc0034081ed417b4f","modified":1682003818586},{"_id":"node_modules/hexo-theme-async/source/css/_variables/index.less","hash":"831bf5eb6f46eaff12ddd7542f52783dff511896","modified":1682003818575},{"_id":"node_modules/hexo-theme-async/source/css/plugins/bootstrap.row.css","hash":"95c954c577f21e537229c4806419206e822eba04","modified":1682003817892},{"_id":"node_modules/hexo-theme-async/source/css/plugins/locomotive-scroll.css","hash":"221f0205ccfc91a68b095f0d02c00e664e9ddf61","modified":1682003818077},{"_id":"node_modules/hexo-theme-async/source/css/plugins/font-awesome.min.css","hash":"6137a9883adce70d78c7f7bbe8af27d91b627d32","modified":1682003818076},{"_id":"node_modules/hexo-theme-async/source/js/plugins/local_search.js","hash":"18823ee20d0f09d2a925e3189a6458620636ee67","modified":1682003818546},{"_id":"node_modules/hexo-theme-async/source/fonts/webfonts/fa-regular-400.woff2","hash":"fbb0d9d51850d824d7eba66e0e210c778d6d42f5","modified":1682003819938},{"_id":"node_modules/hexo-theme-async/layout/_partial/sidebar/card/info.ejs","hash":"dfa5d015d7174ad02df0099dadfab3e35e85dd59","modified":1682003818094},{"_id":"node_modules/hexo-theme-async/layout/_partial/sidebar/card/toc.ejs","hash":"1a82facc6d08f12811783c6d6cc7ad565d859cb6","modified":1682003818102},{"_id":"node_modules/hexo-theme-async/source/js/plugins/typing.js","hash":"49e5af4f80da9bfd46a81495711822de87719656","modified":1682003818551},{"_id":"node_modules/hexo-theme-async/layout/_partial/sidebar/card/email.ejs","hash":"d8ceed83ba3b0af7d361ca9254a62afd6e8f741e","modified":1682003818087},{"_id":"node_modules/hexo-theme-async/layout/_partial/sidebar/card/social.ejs","hash":"4543c52a486a87f718fcfe03b6ef59bd771759d5","modified":1682003818101},{"_id":"node_modules/hexo-theme-async/layout/_partial/sidebar/card/user.ejs","hash":"1289fe4e482586510ed2c9a4215c0a4a21dcbec0","modified":1682003818103},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/comment/twikoo.less","hash":"f365099c5fcae37b4c0163c09d9a498aae61af44","modified":1682003818584},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/comment/index.less","hash":"157debbb5fbf62389dc49a8998c8ee13da526335","modified":1682003818567},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/comment/bcomments.less","hash":"d387268ed3486bf66db9243114d55ac974b73fb1","modified":1682003818558},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/index.less","hash":"89e4484929bc4255b44b9a9581ab548e4a290046","modified":1682003818572},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/fancybox/index.less","hash":"f2286a1158475425b8715979c4ae7d90d206c438","modified":1682003818569},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/highlight/index.less","hash":"77897529e46022ea46a5c352622fac891ba0c406","modified":1682003818571},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/read-mode/read-mode.less","hash":"687dd581162d5e35e0d871fbc6392a7cadc4ecb9","modified":1682003818580},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/highlight/minix.less","hash":"5b7def3a700ef357a53c2660a22b22ee30727596","modified":1682003818577},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/read-mode/index.less","hash":"ba5c0ec35a657fd1d37ef11637e9d11c1ef37fc6","modified":1682003818573},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/highlight/theme.less","hash":"a967c2857811320bdf85e701a8efc06bac048c60","modified":1682003818582},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/reward/index.less","hash":"a3b79acb10a9cd86c667729e77cb00580fb9adf8","modified":1682003818573},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/read-mode/single-column.less","hash":"5589661bf35cd6c5bc08a9005edbf95906bcf178","modified":1682003818581},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/reward/reward.less","hash":"bd4a0cda40f3407cc73bd585c5d318074bfb4bfa","modified":1682003818581},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/search/index.less","hash":"7f57003ebd89d50a4e6a8a4c6636bcd129e22eed","modified":1682003818574},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/highlight/highlight/diff.less","hash":"3879fa32f66d23b74c6e6dd016f58ea1eff4d39c","modified":1682003818562},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/highlight/prismjs/diff.less","hash":"3b6f63fa0c8f033219aa2cc6e6bd9e33a0a8ab81","modified":1682003818565},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/search/search.less","hash":"306d1dd8a24b36c3ed602a6e03e6ba0370722d70","modified":1682003818581},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/highlight/prismjs/line-number.less","hash":"b5e9230948a1cdf0dc198498ee6694c26f26b88e","modified":1682003818576},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/highlight/prismjs/index.less","hash":"d2411c499a7b83284c71655574063c14bbbe5fce","modified":1682003818571},{"_id":"node_modules/hexo-theme-async/source/css/_components/plugins/highlight/highlight/index.less","hash":"552296ca563930093a85290f84316bbb76821175","modified":1682003818570},{"_id":"node_modules/hexo-theme-async/source/fonts/webfonts/fa-solid-900.woff2","hash":"80644191098f863f25be27841c0d92c452cf2327","modified":1682003819982},{"_id":"node_modules/hexo-theme-async/source/fonts/webfonts/fa-brands-400.woff2","hash":"f988b2efe9434b0af28943708d33dd3afad9a5ba","modified":1682003819927},{"_id":"node_modules/hexo-theme-async/source/css/plugins/bootstrap.min.css","hash":"b6f019002b87e86a07275eacd3c35a13c378b5c3","modified":1682003817890},{"_id":"node_modules/hexo-theme-async/source/img/banner.png","hash":"1fc9c8d054e401d68788027107c9392f047aa5fa","modified":1682003819695},{"_id":"public/log.svg","hash":"007ce717bd046aa1c558dc09b32619832e7bea4d","modified":1682155594141},{"_id":"public/img/avatar.jpg","hash":"e9e4108ab199202288ee68342a40064649c3d7c1","modified":1682004944389},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1682004944389},{"_id":"public/img/block.jpg","hash":"1dd350354bd3fe2e7287dfe063d7783e4ab91090","modified":1682004944389},{"_id":"public/img/favicon.svg","hash":"ef922eea66dc950fb1327dd4571d777b8aeb8161","modified":1682004944389},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1682004944389},{"_id":"public/failure.ico","hash":"5eec5c163400d8ece74286da49130da1ead3f6f6","modified":1682004944389},{"_id":"public/fonts/webfonts/fa-regular-400.woff2","hash":"fbb0d9d51850d824d7eba66e0e210c778d6d42f5","modified":1682004944389},{"_id":"public/sw.js","hash":"01b07120762ab155c99478afb36075d4d7e2bc9c","modified":1682004944389},{"_id":"public/css/plugins/bootstrap.row.css","hash":"95c954c577f21e537229c4806419206e822eba04","modified":1682004944389},{"_id":"public/css/plugins/locomotive-scroll.css","hash":"221f0205ccfc91a68b095f0d02c00e664e9ddf61","modified":1682004944389},{"_id":"public/js/plugins/local_search.js","hash":"18823ee20d0f09d2a925e3189a6458620636ee67","modified":1682004944389},{"_id":"public/js/plugins/typing.js","hash":"49e5af4f80da9bfd46a81495711822de87719656","modified":1682004944389},{"_id":"public/js/main.js","hash":"ffb319279f80567f25383a01099b40ac81b0ff4f","modified":1682004944389},{"_id":"public/css/plugins/font-awesome.min.css","hash":"6137a9883adce70d78c7f7bbe8af27d91b627d32","modified":1682004944389},{"_id":"public/css/plugins/bootstrap.min.css","hash":"b6f019002b87e86a07275eacd3c35a13c378b5c3","modified":1682004944389},{"_id":"public/fonts/webfonts/fa-brands-400.woff2","hash":"f988b2efe9434b0af28943708d33dd3afad9a5ba","modified":1682004944389},{"_id":"public/fonts/webfonts/fa-solid-900.woff2","hash":"80644191098f863f25be27841c0d92c452cf2327","modified":1682004944389},{"_id":"public/img/banner.png","hash":"1fc9c8d054e401d68788027107c9392f047aa5fa","modified":1682004944389},{"_id":"public/css/index.css","hash":"b298b1a38048a3de537dfb521637c45a264f2761","modified":1682004944389},{"_id":"source/_posts/categories/index.md","hash":"caee5eaead5cced87f47432d8a3bad1f0a020d32","modified":1682156392291},{"_id":"source/_posts/2025-03-24.md","hash":"5545001e37b7049a086ea88d58061ef6e4e9287c","modified":1742809246937},{"_id":"source/_posts/book_read_20230507.md","hash":"f8740d03f1ebbd6ec32eaefc291392c132a0b55c","modified":1742807860583},{"_id":"source/about/index.md","hash":"f03aba3de7ee18f83ef018254fa73a4f907a34c5","modified":1742807860583},{"_id":"source/tags/index.md","hash":"fc81d39196da647f9cb6be7342ee578fa4231dff","modified":1742807860583},{"_id":"source/links/index.md","hash":"7b088fbb4c20bf5c06bb122d453e57fb4946451c","modified":1742807860583},{"_id":"public/links/index.html","hash":"c56dd0e66cb0da46c052b4298d3fa8b6bdee9d3f","modified":1742811208894},{"_id":"public/about/index.html","hash":"fde58112f0fd28f9704045ed6e73d26e86b585c7","modified":1742811208894},{"_id":"public/tags/index.html","hash":"1f614164e52448f34853e3efb8ba4726633d7381","modified":1745830107884},{"_id":"public/2025/03/24/2025-03-24/index.html","hash":"5f9d838f0be0953e3a4d898652affb224359e5d1","modified":1742811208894},{"_id":"public/2025/03/24/hello-world/index.html","hash":"7509864a65a4b0d2aa3bf957ad9efef5aff180b2","modified":1742811208894},{"_id":"public/2025/03/24/book_read_20230507/index.html","hash":"620534b7f11273570e60a3fda29dea6b294e9816","modified":1742811208894},{"_id":"public/1970/01/01/categories/index/index.html","hash":"9be2d6266728e875cdb46c3ed5075b1c71b6097f","modified":1743149829115},{"_id":"public/archives/1970/index.html","hash":"87b14668a120df8431683671f46fff5123e9bfa6","modified":1745830107884},{"_id":"public/archives/1970/01/index.html","hash":"8b870782d45d3884c17bb6064b192d45e07ee8fd","modified":1745830107884},{"_id":"public/archives/2025/index.html","hash":"b20e0266c69e6302f40dd7a9456885c35b988f90","modified":1745830107884},{"_id":"public/archives/2025/03/index.html","hash":"1f96187f3c191ec927ddb4bc734e0034a98c7f42","modified":1745830107884},{"_id":"public/tags/总结/index.html","hash":"7776e6f32c9df396bb635d51d37b724cdddf0f6f","modified":1745830107884},{"_id":"public/categories/总结/index.html","hash":"37adc66169f60cf2806b277412965a245bef2e81","modified":1745830107884},{"_id":"public/categories/读书笔记/index.html","hash":"8eef234b42e52a6e60ebd1f411a0f06717ad7431","modified":1745830107884},{"_id":"public/categories/博客/index.html","hash":"75b8507a5758dc76c26d53c5e856fdc28840cf29","modified":1745830107884},{"_id":"source/_posts/Rust-高性能原因解析.md","hash":"e6a279a6e428087b0e3c33ad305ef1c0a5e8e97e","modified":1742811158175},{"_id":"public/2025/03/24/Rust-高性能原因解析/index.html","hash":"5ff952c3a3c706878d800e36e2fb8edd8460d5ca","modified":1743149829115},{"_id":"public/tags/rust/index.html","hash":"91a25feda4e39f7200311a96bd9f150cb330a204","modified":1745830107884},{"_id":"source/_posts/Golang-并发编程实战总结.md","hash":"acb55dfcee185cdd4ff66ea82656a1fda7a5541d","modified":1743149767392},{"_id":"public/2025/03/28/Golang-并发编程实战总结/index.html","hash":"12504563be456f3af5183c74d512413f6ac132a3","modified":1745830107884},{"_id":"public/tags/golang/index.html","hash":"d2c4fb46f500b00ae1af924aeeb1cf17bab2b1ef","modified":1745830107884},{"_id":"source/_posts/币圈学习-衍生品系列01.md","hash":"61cd4f1f77adf9c2778e34e6ca60913c32627fa8","modified":1745830031029},{"_id":"public/2025/04/28/币圈学习-衍生品系列01/index.html","hash":"7f0aa83779bd30b2bd6fbd473c67ff8210257abc","modified":1745830107884},{"_id":"public/archives/2025/04/index.html","hash":"02c263bed6bfad160dfd700e0dc7903bac799708","modified":1745830107884},{"_id":"public/tags/币圈/index.html","hash":"5580c771d21b3cccfc8c8aa1d59749dfd82461b0","modified":1745830107884}],"Category":[{"name":"测试分类1","_id":"clgrseotv00027dn982gfczn9"},{"name":"总结","_id":"cm8mvlbll0004a06cabr8avx3"},{"name":"读书笔记","_id":"cm8mvlblm0007a06cgryc7s7p"},{"name":"博客","_id":"cm8mvlblm000aa06c4uh4ambt"}],"Data":[{"_id":"languages","data":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}],"Page":[{"title":"友情链接","date":"2023-04-28T05:36:35.000Z","layout":"links","_content":"","source":"links/index.md","raw":"---\ntitle: 友情链接\ndate: 2023-04-28 13:36:35\nlayout: links\n---\n","updated":"2025-03-24T09:17:40.583Z","path":"links/index.html","comments":1,"_id":"cm8mvlblj0000a06cezfkb01d","content":"","site":{"data":{"languages":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}},"excerpt":"","more":""},{"title":"关于","date":"2023-04-28T05:38:55.000Z","layout":"about","_content":"## 【关于博主】\n\n## 【程序员贺同学】\n- 【昵称】贺同学/贺哥\n- 【坐标】北京\n- 【标签】95年双鱼，211硕/大厂程序员/学习博主\n- 【技术栈】C++/Python/Golang 后端开发，做过搜索架构等方向\n- 【一句话介绍的话】典型科班理工男，国内头部互联网搜狗/腾讯/字节大厂经历，擅长互联网简历/校招/社招/考研辅导/职业规划\n\n## 【经历】 \n- 二本学校考研帝都 211 计算机工科院校\n- 跑步爱好者，自媒体创作者，终身学习者，累计跑步9年，写作公众号5年，全网粉丝3w+\n\n## 【了解更多】\n- #公众号：程序员贺同学 （技术/思考）\n- #视频号：程序员贺同学 \n- 平时不闲聊，我的免费知识星球，分享日常思考，可免费提问 https://t.zsxq.com/0bZvOPT0C\n\n## 【优秀圈子 & 技术课程推荐】\n- [点击这里，开启新的世界](https://jnvsh9w7fs.feishu.cn/docx/GxPLdlGAnovtWDxWC8qcR0TdnGg)\n\n## 【座右铭】\n- 空无一物，无限进步\n- 真诚无敌，极致利他","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2023-04-28 13:38:55\nlayout: about\n---\n## 【关于博主】\n\n## 【程序员贺同学】\n- 【昵称】贺同学/贺哥\n- 【坐标】北京\n- 【标签】95年双鱼，211硕/大厂程序员/学习博主\n- 【技术栈】C++/Python/Golang 后端开发，做过搜索架构等方向\n- 【一句话介绍的话】典型科班理工男，国内头部互联网搜狗/腾讯/字节大厂经历，擅长互联网简历/校招/社招/考研辅导/职业规划\n\n## 【经历】 \n- 二本学校考研帝都 211 计算机工科院校\n- 跑步爱好者，自媒体创作者，终身学习者，累计跑步9年，写作公众号5年，全网粉丝3w+\n\n## 【了解更多】\n- #公众号：程序员贺同学 （技术/思考）\n- #视频号：程序员贺同学 \n- 平时不闲聊，我的免费知识星球，分享日常思考，可免费提问 https://t.zsxq.com/0bZvOPT0C\n\n## 【优秀圈子 & 技术课程推荐】\n- [点击这里，开启新的世界](https://jnvsh9w7fs.feishu.cn/docx/GxPLdlGAnovtWDxWC8qcR0TdnGg)\n\n## 【座右铭】\n- 空无一物，无限进步\n- 真诚无敌，极致利他","updated":"2025-03-24T09:17:40.583Z","path":"about/index.html","comments":1,"_id":"cm8mvlblk0002a06c4am60irj","content":"<h2 id=\"【关于博主】\"><a href=\"#【关于博主】\" class=\"headerlink\" title=\"【关于博主】\"></a>【关于博主】</h2><h2 id=\"【程序员贺同学】\"><a href=\"#【程序员贺同学】\" class=\"headerlink\" title=\"【程序员贺同学】\"></a>【程序员贺同学】</h2><ul>\n<li>【昵称】贺同学&#x2F;贺哥</li>\n<li>【坐标】北京</li>\n<li>【标签】95年双鱼，211硕&#x2F;大厂程序员&#x2F;学习博主</li>\n<li>【技术栈】C++&#x2F;Python&#x2F;Golang 后端开发，做过搜索架构等方向</li>\n<li>【一句话介绍的话】典型科班理工男，国内头部互联网搜狗&#x2F;腾讯&#x2F;字节大厂经历，擅长互联网简历&#x2F;校招&#x2F;社招&#x2F;考研辅导&#x2F;职业规划</li>\n</ul>\n<h2 id=\"【经历】\"><a href=\"#【经历】\" class=\"headerlink\" title=\"【经历】\"></a>【经历】</h2><ul>\n<li>二本学校考研帝都 211 计算机工科院校</li>\n<li>跑步爱好者，自媒体创作者，终身学习者，累计跑步9年，写作公众号5年，全网粉丝3w+</li>\n</ul>\n<h2 id=\"【了解更多】\"><a href=\"#【了解更多】\" class=\"headerlink\" title=\"【了解更多】\"></a>【了解更多】</h2><ul>\n<li>#公众号：程序员贺同学 （技术&#x2F;思考）</li>\n<li>#视频号：程序员贺同学 </li>\n<li>平时不闲聊，我的免费知识星球，分享日常思考，可免费提问 <a href=\"https://t.zsxq.com/0bZvOPT0C\">https://t.zsxq.com/0bZvOPT0C</a></li>\n</ul>\n<h2 id=\"【优秀圈子-amp-技术课程推荐】\"><a href=\"#【优秀圈子-amp-技术课程推荐】\" class=\"headerlink\" title=\"【优秀圈子 &amp; 技术课程推荐】\"></a>【优秀圈子 &amp; 技术课程推荐】</h2><ul>\n<li><a href=\"https://jnvsh9w7fs.feishu.cn/docx/GxPLdlGAnovtWDxWC8qcR0TdnGg\">点击这里，开启新的世界</a></li>\n</ul>\n<h2 id=\"【座右铭】\"><a href=\"#【座右铭】\" class=\"headerlink\" title=\"【座右铭】\"></a>【座右铭】</h2><ul>\n<li>空无一物，无限进步</li>\n<li>真诚无敌，极致利他</li>\n</ul>\n","site":{"data":{"languages":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}},"excerpt":"","more":"<h2 id=\"【关于博主】\"><a href=\"#【关于博主】\" class=\"headerlink\" title=\"【关于博主】\"></a>【关于博主】</h2><h2 id=\"【程序员贺同学】\"><a href=\"#【程序员贺同学】\" class=\"headerlink\" title=\"【程序员贺同学】\"></a>【程序员贺同学】</h2><ul>\n<li>【昵称】贺同学&#x2F;贺哥</li>\n<li>【坐标】北京</li>\n<li>【标签】95年双鱼，211硕&#x2F;大厂程序员&#x2F;学习博主</li>\n<li>【技术栈】C++&#x2F;Python&#x2F;Golang 后端开发，做过搜索架构等方向</li>\n<li>【一句话介绍的话】典型科班理工男，国内头部互联网搜狗&#x2F;腾讯&#x2F;字节大厂经历，擅长互联网简历&#x2F;校招&#x2F;社招&#x2F;考研辅导&#x2F;职业规划</li>\n</ul>\n<h2 id=\"【经历】\"><a href=\"#【经历】\" class=\"headerlink\" title=\"【经历】\"></a>【经历】</h2><ul>\n<li>二本学校考研帝都 211 计算机工科院校</li>\n<li>跑步爱好者，自媒体创作者，终身学习者，累计跑步9年，写作公众号5年，全网粉丝3w+</li>\n</ul>\n<h2 id=\"【了解更多】\"><a href=\"#【了解更多】\" class=\"headerlink\" title=\"【了解更多】\"></a>【了解更多】</h2><ul>\n<li>#公众号：程序员贺同学 （技术&#x2F;思考）</li>\n<li>#视频号：程序员贺同学 </li>\n<li>平时不闲聊，我的免费知识星球，分享日常思考，可免费提问 <a href=\"https://t.zsxq.com/0bZvOPT0C\">https://t.zsxq.com/0bZvOPT0C</a></li>\n</ul>\n<h2 id=\"【优秀圈子-amp-技术课程推荐】\"><a href=\"#【优秀圈子-amp-技术课程推荐】\" class=\"headerlink\" title=\"【优秀圈子 &amp; 技术课程推荐】\"></a>【优秀圈子 &amp; 技术课程推荐】</h2><ul>\n<li><a href=\"https://jnvsh9w7fs.feishu.cn/docx/GxPLdlGAnovtWDxWC8qcR0TdnGg\">点击这里，开启新的世界</a></li>\n</ul>\n<h2 id=\"【座右铭】\"><a href=\"#【座右铭】\" class=\"headerlink\" title=\"【座右铭】\"></a>【座右铭】</h2><ul>\n<li>空无一物，无限进步</li>\n<li>真诚无敌，极致利他</li>\n</ul>\n"},{"title":"标签","date":"2023-04-28T05:35:34.000Z","layout":"tag","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2023-04-28 13:35:34\nlayout: tag\n---","updated":"2025-03-24T09:17:40.583Z","path":"tags/index.html","comments":1,"_id":"cm8mvlbll0006a06cg6i6hq38","content":"","site":{"data":{"languages":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}},"excerpt":"","more":""}],"Post":[{"title":"2023 0422 我的全球唯一域名诞生了！","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start 我的第一篇博客!\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: 2023 0422 我的全球唯一域名诞生了！\ncategories: 博客\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start 我的第一篇博客!\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2025-03-24T09:17:40.583Z","updated":"2025-03-24T09:39:28.760Z","_id":"clgp9kd4i00007xn9gypl6efa","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start-我的第一篇博客\"><a href=\"#Quick-Start-我的第一篇博客\" class=\"headerlink\" title=\"Quick Start 我的第一篇博客!\"></a>Quick Start 我的第一篇博客!</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"languages":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start-我的第一篇博客\"><a href=\"#Quick-Start-我的第一篇博客\" class=\"headerlink\" title=\"Quick Start 我的第一篇博客!\"></a>Quick Start 我的第一篇博客!</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"分类","date":"1970-01-01T05:37:10.422Z","layout":"category","_content":"","source":"_posts/categories/index.md","raw":"---\ntitle: 分类\ndate: 20230422\nlayout: category\n---","slug":"categories/index","published":1,"updated":"2023-04-22T09:40:11.468Z","_id":"clgrs9d5q00017dn9he11ha63","comments":1,"photos":[],"link":"","content":"","site":{"data":{"languages":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}},"excerpt":"","more":""},{"title":"20250324-博客重启啦！","date":"2025-03-24T09:38:20.000Z","_content":"\n## 重启博客 学习 Rust\n- [x] 学习Rust\n- [x] 学习Rust的生命周期\n- [x] 学习Rust的所有权\n- [x] 学习Rust的借用\n- [x] 学习Rust的迭代器\n- [x] 学习Rust的模式匹配\n- [x] 学习Rust的泛型\n- [x] 学习Rust的宏\n- [x] 学习Rust的错误处理\n- [x] 学习Rust的并发\n- [x] 学习Rust的标准库\n- [x] 学习Rust的第三方库","source":"_posts/2025-03-24.md","raw":"---\ntitle: 20250324-博客重启啦！\ndate: 2025-03-24 17:38:20\ntags: 总结\ncategories: 总结\n---\n\n## 重启博客 学习 Rust\n- [x] 学习Rust\n- [x] 学习Rust的生命周期\n- [x] 学习Rust的所有权\n- [x] 学习Rust的借用\n- [x] 学习Rust的迭代器\n- [x] 学习Rust的模式匹配\n- [x] 学习Rust的泛型\n- [x] 学习Rust的宏\n- [x] 学习Rust的错误处理\n- [x] 学习Rust的并发\n- [x] 学习Rust的标准库\n- [x] 学习Rust的第三方库","slug":"2025-03-24","published":1,"updated":"2025-03-24T09:40:46.937Z","_id":"cm8mvlblj0001a06cd4aa3nei","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"重启博客-学习-Rust\"><a href=\"#重启博客-学习-Rust\" class=\"headerlink\" title=\"重启博客 学习 Rust\"></a>重启博客 学习 Rust</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的生命周期</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的所有权</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的借用</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的迭代器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的模式匹配</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的泛型</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的宏</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的错误处理</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的并发</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的标准库</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的第三方库</li>\n</ul>\n","site":{"data":{"languages":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}},"excerpt":"","more":"<h2 id=\"重启博客-学习-Rust\"><a href=\"#重启博客-学习-Rust\" class=\"headerlink\" title=\"重启博客 学习 Rust\"></a>重启博客 学习 Rust</h2><ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的生命周期</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的所有权</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的借用</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的迭代器</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的模式匹配</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的泛型</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的宏</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的错误处理</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的并发</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的标准库</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 学习Rust的第三方库</li>\n</ul>\n"},{"title":"《我在北京送快递》读书笔记","_content":"\n> 周末发现了一本有趣的书籍📚  https://book.douban.com/subject/36150423/\n\n《我在北京送快递》的作者可以说是一个狠人，从步入社会到如今十几年间，在广东、广西、云南、上海、北京等地辗转打工，做过快递员、夜班拣货工人、便利店店员、保安、自行车店销售、网店工作人员、服装店导购、加油站加油工等基层工作。\n\n自己还曾经创过业，现在是一名写作者。作为一名“底层打工人”，他经历了很多人未曾听闻的生活，也让我们了解了很多行业内幕。\n\n整本书 ～12w 字，不算长，但是能从详细的语言描述上感受到作者质朴的工作生活经历以及真挚的情感，特别是在生活中不断产生的各种感悟以及思考，非常真实也非常能走到人心坎里。豆瓣上还有一些彩蛋，比如作者的自述（为什么要出这本书和读库发现他的故事）、媒体采访作者的片段（还有一些真实的照片），推荐大家阅读。\n\n整理了下作者在书中表达的感悟和自己的一些读后感，也许会对你有所帮助。\n\n## 作者感悟\n\n- “就像深海里的鱼都是瞎子、沙漠里的动物都很耐渴一样，我是一个怎样的人，很大程度上是由我所处的环境，而不是由我的所谓本性决定的。”\n\n- “卑贱的人如果心怀不满，就只会欺负别的卑贱的人，因为反抗权势是要吃苦头的。如果实在是谁也欺负不了，那就只能去虐待动物了。人们常常说，爱情是盲目的。但在我看来，爱情恰恰最不盲目、最不功利、最忠于本心。相反，仇恨才是盲目的。”\n\n- “每个人都会以己度人，你永远无法让一个不真诚的人相信你的真诚。反之，你根本没必要向一个真诚的人证明你的真诚。”\n\n- “我们也各有各的压力，各有各家里不顺心的事，谁也没有余力顾别人。在那种工作场所里，每个人都被生活压榨着，同情心因此透支，然后不知不觉地变得麻木、冷漠。”\n\n- “所谓的自由，实际上在于你能意识到什么，而不在于你享有什么。对于一个文化水平不高的农民来说，尽管每年的农务受到二十四节气的限制，但他不会感觉到有什么不自由。\n\n- 农闲的时候和亲朋打打牌，农忙的时候忙完一天的农活儿，晚上回家喝点儿小酒，感觉惬意且满足，仿佛自己所做的都是自己想做的。可是文化水平越高，思维和意识越复杂，人就越难在工作中感觉到自由。”\n\n- 实际上，通过写作我在一定程度上超越了打工和自由的对立：在有限的选择和局促的现实中，我越来越感觉到生活中许多平凡隽永的时刻，要比现实困扰的方方面面对人生更具决定意义。感谢浦睿文化的编辑普照\n\n\n## 读后感 \n- 每个人的经历都是难得的，每个人的经历也是独一无二，特别赞同作者在书中的一段话，如今我不会再为自己和别人的差异感到惶恐不安，相反，我珍视自己的个性。虽然我仍然很无知和胆怯，但在这之下多了一份坚持和信心。此后无论我打工或写作，那对我来说都是一种自我精神的建设。\n\n\n- 正视社会的繁杂，正视自己的差异，学会接受现实，也学会保留个性，这就是社会阅历带给作者的成长。\n\n- 精神领域的成长是人生从茫然随波到自我审视的关键，然后才能发现自我、接受自我，开始调整行为和思想，使得内外逐渐趋于一致，达至和谐。\n\n- 一个人稳定的内核建设太重要了，一个人有了稳定的精神内核，就不会为谁的贬低而诚惶诚恐，也不会谁的称赞而沾沾自喜，这种自我认同感的增强，带来的自信和不受他人眼光影响\n\n- 个人意识，是教育最应该达到的基本目的，让每一个人明白自己存在的意义，不是由于外界的肯定，而是存在本身就有意义，这份坚定之上，再去不断的发展自己。作者通过经历的事情和学习，不断反思，得到了这样的结论，实在值得赞叹！\n\n- 幸运的人用童年治愈一生，不幸的人用一生治愈童年我也感受到，那些快乐的时光才成为困苦之中的精神力量。\n\n- 有人按照自己喜欢的方式做自己喜欢的事情，却恰好能够满足雇主、客户或外部机制等的要求，并由此抵达了某种自由。但是这样的幸运听起来似乎可遇不可求。这样的生活实在是太幸运了\n\n- 尽管褒贬不一，依然推荐阅读。积极的，阴暗的，沉默的，冲动的，温情的，崩溃的，宽容的，自私的，工作和生活的点滴。记忆尤深的是“榴莲的愤怒”，心里小小的恶，各种对自我不耻的剖析，亦比多数人勇敢。\n\n- “真正有魅力的人，一定是个灵魂有趣的人。有趣的灵魂，一定是对世界充满热爱，即便经历低谷，遭遇挫折，对生活不计回报的热爱永不朽坏；有趣的灵魂，一定是对社会充满责任，热爱家人，热爱朋友，愿意为这个社会做自己的贡献；有趣的灵魂，一定拥有广袤的视野，这视野，来自于丰富的阅历，渊博的知识，和从不间断的学习；有趣的灵魂，一定拥有乐观和豁达，不以物喜，不以己悲，不因挫折一蹶不振”\n\n![i1Ai7x.jpeg](https://i.328888.xyz/2023/05/07/i1Ai7x.jpeg)","source":"_posts/book_read_20230507.md","raw":"---\ntitle: 《我在北京送快递》读书笔记\ncategories: 读书笔记\n---\n\n> 周末发现了一本有趣的书籍📚  https://book.douban.com/subject/36150423/\n\n《我在北京送快递》的作者可以说是一个狠人，从步入社会到如今十几年间，在广东、广西、云南、上海、北京等地辗转打工，做过快递员、夜班拣货工人、便利店店员、保安、自行车店销售、网店工作人员、服装店导购、加油站加油工等基层工作。\n\n自己还曾经创过业，现在是一名写作者。作为一名“底层打工人”，他经历了很多人未曾听闻的生活，也让我们了解了很多行业内幕。\n\n整本书 ～12w 字，不算长，但是能从详细的语言描述上感受到作者质朴的工作生活经历以及真挚的情感，特别是在生活中不断产生的各种感悟以及思考，非常真实也非常能走到人心坎里。豆瓣上还有一些彩蛋，比如作者的自述（为什么要出这本书和读库发现他的故事）、媒体采访作者的片段（还有一些真实的照片），推荐大家阅读。\n\n整理了下作者在书中表达的感悟和自己的一些读后感，也许会对你有所帮助。\n\n## 作者感悟\n\n- “就像深海里的鱼都是瞎子、沙漠里的动物都很耐渴一样，我是一个怎样的人，很大程度上是由我所处的环境，而不是由我的所谓本性决定的。”\n\n- “卑贱的人如果心怀不满，就只会欺负别的卑贱的人，因为反抗权势是要吃苦头的。如果实在是谁也欺负不了，那就只能去虐待动物了。人们常常说，爱情是盲目的。但在我看来，爱情恰恰最不盲目、最不功利、最忠于本心。相反，仇恨才是盲目的。”\n\n- “每个人都会以己度人，你永远无法让一个不真诚的人相信你的真诚。反之，你根本没必要向一个真诚的人证明你的真诚。”\n\n- “我们也各有各的压力，各有各家里不顺心的事，谁也没有余力顾别人。在那种工作场所里，每个人都被生活压榨着，同情心因此透支，然后不知不觉地变得麻木、冷漠。”\n\n- “所谓的自由，实际上在于你能意识到什么，而不在于你享有什么。对于一个文化水平不高的农民来说，尽管每年的农务受到二十四节气的限制，但他不会感觉到有什么不自由。\n\n- 农闲的时候和亲朋打打牌，农忙的时候忙完一天的农活儿，晚上回家喝点儿小酒，感觉惬意且满足，仿佛自己所做的都是自己想做的。可是文化水平越高，思维和意识越复杂，人就越难在工作中感觉到自由。”\n\n- 实际上，通过写作我在一定程度上超越了打工和自由的对立：在有限的选择和局促的现实中，我越来越感觉到生活中许多平凡隽永的时刻，要比现实困扰的方方面面对人生更具决定意义。感谢浦睿文化的编辑普照\n\n\n## 读后感 \n- 每个人的经历都是难得的，每个人的经历也是独一无二，特别赞同作者在书中的一段话，如今我不会再为自己和别人的差异感到惶恐不安，相反，我珍视自己的个性。虽然我仍然很无知和胆怯，但在这之下多了一份坚持和信心。此后无论我打工或写作，那对我来说都是一种自我精神的建设。\n\n\n- 正视社会的繁杂，正视自己的差异，学会接受现实，也学会保留个性，这就是社会阅历带给作者的成长。\n\n- 精神领域的成长是人生从茫然随波到自我审视的关键，然后才能发现自我、接受自我，开始调整行为和思想，使得内外逐渐趋于一致，达至和谐。\n\n- 一个人稳定的内核建设太重要了，一个人有了稳定的精神内核，就不会为谁的贬低而诚惶诚恐，也不会谁的称赞而沾沾自喜，这种自我认同感的增强，带来的自信和不受他人眼光影响\n\n- 个人意识，是教育最应该达到的基本目的，让每一个人明白自己存在的意义，不是由于外界的肯定，而是存在本身就有意义，这份坚定之上，再去不断的发展自己。作者通过经历的事情和学习，不断反思，得到了这样的结论，实在值得赞叹！\n\n- 幸运的人用童年治愈一生，不幸的人用一生治愈童年我也感受到，那些快乐的时光才成为困苦之中的精神力量。\n\n- 有人按照自己喜欢的方式做自己喜欢的事情，却恰好能够满足雇主、客户或外部机制等的要求，并由此抵达了某种自由。但是这样的幸运听起来似乎可遇不可求。这样的生活实在是太幸运了\n\n- 尽管褒贬不一，依然推荐阅读。积极的，阴暗的，沉默的，冲动的，温情的，崩溃的，宽容的，自私的，工作和生活的点滴。记忆尤深的是“榴莲的愤怒”，心里小小的恶，各种对自我不耻的剖析，亦比多数人勇敢。\n\n- “真正有魅力的人，一定是个灵魂有趣的人。有趣的灵魂，一定是对世界充满热爱，即便经历低谷，遭遇挫折，对生活不计回报的热爱永不朽坏；有趣的灵魂，一定是对社会充满责任，热爱家人，热爱朋友，愿意为这个社会做自己的贡献；有趣的灵魂，一定拥有广袤的视野，这视野，来自于丰富的阅历，渊博的知识，和从不间断的学习；有趣的灵魂，一定拥有乐观和豁达，不以物喜，不以己悲，不因挫折一蹶不振”\n\n![i1Ai7x.jpeg](https://i.328888.xyz/2023/05/07/i1Ai7x.jpeg)","slug":"book_read_20230507","published":1,"date":"2025-03-24T09:17:40.583Z","updated":"2025-03-24T09:17:40.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm8mvlblk0003a06cewof913k","content":"<blockquote>\n<p>周末发现了一本有趣的书籍📚  <a href=\"https://book.douban.com/subject/36150423/\">https://book.douban.com/subject/36150423/</a></p>\n</blockquote>\n<p>《我在北京送快递》的作者可以说是一个狠人，从步入社会到如今十几年间，在广东、广西、云南、上海、北京等地辗转打工，做过快递员、夜班拣货工人、便利店店员、保安、自行车店销售、网店工作人员、服装店导购、加油站加油工等基层工作。</p>\n<p>自己还曾经创过业，现在是一名写作者。作为一名“底层打工人”，他经历了很多人未曾听闻的生活，也让我们了解了很多行业内幕。</p>\n<p>整本书 ～12w 字，不算长，但是能从详细的语言描述上感受到作者质朴的工作生活经历以及真挚的情感，特别是在生活中不断产生的各种感悟以及思考，非常真实也非常能走到人心坎里。豆瓣上还有一些彩蛋，比如作者的自述（为什么要出这本书和读库发现他的故事）、媒体采访作者的片段（还有一些真实的照片），推荐大家阅读。</p>\n<p>整理了下作者在书中表达的感悟和自己的一些读后感，也许会对你有所帮助。</p>\n<h2 id=\"作者感悟\"><a href=\"#作者感悟\" class=\"headerlink\" title=\"作者感悟\"></a>作者感悟</h2><ul>\n<li><p>“就像深海里的鱼都是瞎子、沙漠里的动物都很耐渴一样，我是一个怎样的人，很大程度上是由我所处的环境，而不是由我的所谓本性决定的。”</p>\n</li>\n<li><p>“卑贱的人如果心怀不满，就只会欺负别的卑贱的人，因为反抗权势是要吃苦头的。如果实在是谁也欺负不了，那就只能去虐待动物了。人们常常说，爱情是盲目的。但在我看来，爱情恰恰最不盲目、最不功利、最忠于本心。相反，仇恨才是盲目的。”</p>\n</li>\n<li><p>“每个人都会以己度人，你永远无法让一个不真诚的人相信你的真诚。反之，你根本没必要向一个真诚的人证明你的真诚。”</p>\n</li>\n<li><p>“我们也各有各的压力，各有各家里不顺心的事，谁也没有余力顾别人。在那种工作场所里，每个人都被生活压榨着，同情心因此透支，然后不知不觉地变得麻木、冷漠。”</p>\n</li>\n<li><p>“所谓的自由，实际上在于你能意识到什么，而不在于你享有什么。对于一个文化水平不高的农民来说，尽管每年的农务受到二十四节气的限制，但他不会感觉到有什么不自由。</p>\n</li>\n<li><p>农闲的时候和亲朋打打牌，农忙的时候忙完一天的农活儿，晚上回家喝点儿小酒，感觉惬意且满足，仿佛自己所做的都是自己想做的。可是文化水平越高，思维和意识越复杂，人就越难在工作中感觉到自由。”</p>\n</li>\n<li><p>实际上，通过写作我在一定程度上超越了打工和自由的对立：在有限的选择和局促的现实中，我越来越感觉到生活中许多平凡隽永的时刻，要比现实困扰的方方面面对人生更具决定意义。感谢浦睿文化的编辑普照</p>\n</li>\n</ul>\n<h2 id=\"读后感\"><a href=\"#读后感\" class=\"headerlink\" title=\"读后感\"></a>读后感</h2><ul>\n<li><p>每个人的经历都是难得的，每个人的经历也是独一无二，特别赞同作者在书中的一段话，如今我不会再为自己和别人的差异感到惶恐不安，相反，我珍视自己的个性。虽然我仍然很无知和胆怯，但在这之下多了一份坚持和信心。此后无论我打工或写作，那对我来说都是一种自我精神的建设。</p>\n</li>\n<li><p>正视社会的繁杂，正视自己的差异，学会接受现实，也学会保留个性，这就是社会阅历带给作者的成长。</p>\n</li>\n<li><p>精神领域的成长是人生从茫然随波到自我审视的关键，然后才能发现自我、接受自我，开始调整行为和思想，使得内外逐渐趋于一致，达至和谐。</p>\n</li>\n<li><p>一个人稳定的内核建设太重要了，一个人有了稳定的精神内核，就不会为谁的贬低而诚惶诚恐，也不会谁的称赞而沾沾自喜，这种自我认同感的增强，带来的自信和不受他人眼光影响</p>\n</li>\n<li><p>个人意识，是教育最应该达到的基本目的，让每一个人明白自己存在的意义，不是由于外界的肯定，而是存在本身就有意义，这份坚定之上，再去不断的发展自己。作者通过经历的事情和学习，不断反思，得到了这样的结论，实在值得赞叹！</p>\n</li>\n<li><p>幸运的人用童年治愈一生，不幸的人用一生治愈童年我也感受到，那些快乐的时光才成为困苦之中的精神力量。</p>\n</li>\n<li><p>有人按照自己喜欢的方式做自己喜欢的事情，却恰好能够满足雇主、客户或外部机制等的要求，并由此抵达了某种自由。但是这样的幸运听起来似乎可遇不可求。这样的生活实在是太幸运了</p>\n</li>\n<li><p>尽管褒贬不一，依然推荐阅读。积极的，阴暗的，沉默的，冲动的，温情的，崩溃的，宽容的，自私的，工作和生活的点滴。记忆尤深的是“榴莲的愤怒”，心里小小的恶，各种对自我不耻的剖析，亦比多数人勇敢。</p>\n</li>\n<li><p>“真正有魅力的人，一定是个灵魂有趣的人。有趣的灵魂，一定是对世界充满热爱，即便经历低谷，遭遇挫折，对生活不计回报的热爱永不朽坏；有趣的灵魂，一定是对社会充满责任，热爱家人，热爱朋友，愿意为这个社会做自己的贡献；有趣的灵魂，一定拥有广袤的视野，这视野，来自于丰富的阅历，渊博的知识，和从不间断的学习；有趣的灵魂，一定拥有乐观和豁达，不以物喜，不以己悲，不因挫折一蹶不振”</p>\n</li>\n</ul>\n<p><img src=\"https://i.328888.xyz/2023/05/07/i1Ai7x.jpeg\" alt=\"i1Ai7x.jpeg\" loading=\"lazy\" onerror='this.onerror=null;this.src=\"/img/404.jpg\"'></p>\n","site":{"data":{"languages":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}},"excerpt":"","more":"<blockquote>\n<p>周末发现了一本有趣的书籍📚  <a href=\"https://book.douban.com/subject/36150423/\">https://book.douban.com/subject/36150423/</a></p>\n</blockquote>\n<p>《我在北京送快递》的作者可以说是一个狠人，从步入社会到如今十几年间，在广东、广西、云南、上海、北京等地辗转打工，做过快递员、夜班拣货工人、便利店店员、保安、自行车店销售、网店工作人员、服装店导购、加油站加油工等基层工作。</p>\n<p>自己还曾经创过业，现在是一名写作者。作为一名“底层打工人”，他经历了很多人未曾听闻的生活，也让我们了解了很多行业内幕。</p>\n<p>整本书 ～12w 字，不算长，但是能从详细的语言描述上感受到作者质朴的工作生活经历以及真挚的情感，特别是在生活中不断产生的各种感悟以及思考，非常真实也非常能走到人心坎里。豆瓣上还有一些彩蛋，比如作者的自述（为什么要出这本书和读库发现他的故事）、媒体采访作者的片段（还有一些真实的照片），推荐大家阅读。</p>\n<p>整理了下作者在书中表达的感悟和自己的一些读后感，也许会对你有所帮助。</p>\n<h2 id=\"作者感悟\"><a href=\"#作者感悟\" class=\"headerlink\" title=\"作者感悟\"></a>作者感悟</h2><ul>\n<li><p>“就像深海里的鱼都是瞎子、沙漠里的动物都很耐渴一样，我是一个怎样的人，很大程度上是由我所处的环境，而不是由我的所谓本性决定的。”</p>\n</li>\n<li><p>“卑贱的人如果心怀不满，就只会欺负别的卑贱的人，因为反抗权势是要吃苦头的。如果实在是谁也欺负不了，那就只能去虐待动物了。人们常常说，爱情是盲目的。但在我看来，爱情恰恰最不盲目、最不功利、最忠于本心。相反，仇恨才是盲目的。”</p>\n</li>\n<li><p>“每个人都会以己度人，你永远无法让一个不真诚的人相信你的真诚。反之，你根本没必要向一个真诚的人证明你的真诚。”</p>\n</li>\n<li><p>“我们也各有各的压力，各有各家里不顺心的事，谁也没有余力顾别人。在那种工作场所里，每个人都被生活压榨着，同情心因此透支，然后不知不觉地变得麻木、冷漠。”</p>\n</li>\n<li><p>“所谓的自由，实际上在于你能意识到什么，而不在于你享有什么。对于一个文化水平不高的农民来说，尽管每年的农务受到二十四节气的限制，但他不会感觉到有什么不自由。</p>\n</li>\n<li><p>农闲的时候和亲朋打打牌，农忙的时候忙完一天的农活儿，晚上回家喝点儿小酒，感觉惬意且满足，仿佛自己所做的都是自己想做的。可是文化水平越高，思维和意识越复杂，人就越难在工作中感觉到自由。”</p>\n</li>\n<li><p>实际上，通过写作我在一定程度上超越了打工和自由的对立：在有限的选择和局促的现实中，我越来越感觉到生活中许多平凡隽永的时刻，要比现实困扰的方方面面对人生更具决定意义。感谢浦睿文化的编辑普照</p>\n</li>\n</ul>\n<h2 id=\"读后感\"><a href=\"#读后感\" class=\"headerlink\" title=\"读后感\"></a>读后感</h2><ul>\n<li><p>每个人的经历都是难得的，每个人的经历也是独一无二，特别赞同作者在书中的一段话，如今我不会再为自己和别人的差异感到惶恐不安，相反，我珍视自己的个性。虽然我仍然很无知和胆怯，但在这之下多了一份坚持和信心。此后无论我打工或写作，那对我来说都是一种自我精神的建设。</p>\n</li>\n<li><p>正视社会的繁杂，正视自己的差异，学会接受现实，也学会保留个性，这就是社会阅历带给作者的成长。</p>\n</li>\n<li><p>精神领域的成长是人生从茫然随波到自我审视的关键，然后才能发现自我、接受自我，开始调整行为和思想，使得内外逐渐趋于一致，达至和谐。</p>\n</li>\n<li><p>一个人稳定的内核建设太重要了，一个人有了稳定的精神内核，就不会为谁的贬低而诚惶诚恐，也不会谁的称赞而沾沾自喜，这种自我认同感的增强，带来的自信和不受他人眼光影响</p>\n</li>\n<li><p>个人意识，是教育最应该达到的基本目的，让每一个人明白自己存在的意义，不是由于外界的肯定，而是存在本身就有意义，这份坚定之上，再去不断的发展自己。作者通过经历的事情和学习，不断反思，得到了这样的结论，实在值得赞叹！</p>\n</li>\n<li><p>幸运的人用童年治愈一生，不幸的人用一生治愈童年我也感受到，那些快乐的时光才成为困苦之中的精神力量。</p>\n</li>\n<li><p>有人按照自己喜欢的方式做自己喜欢的事情，却恰好能够满足雇主、客户或外部机制等的要求，并由此抵达了某种自由。但是这样的幸运听起来似乎可遇不可求。这样的生活实在是太幸运了</p>\n</li>\n<li><p>尽管褒贬不一，依然推荐阅读。积极的，阴暗的，沉默的，冲动的，温情的，崩溃的，宽容的，自私的，工作和生活的点滴。记忆尤深的是“榴莲的愤怒”，心里小小的恶，各种对自我不耻的剖析，亦比多数人勇敢。</p>\n</li>\n<li><p>“真正有魅力的人，一定是个灵魂有趣的人。有趣的灵魂，一定是对世界充满热爱，即便经历低谷，遭遇挫折，对生活不计回报的热爱永不朽坏；有趣的灵魂，一定是对社会充满责任，热爱家人，热爱朋友，愿意为这个社会做自己的贡献；有趣的灵魂，一定拥有广袤的视野，这视野，来自于丰富的阅历，渊博的知识，和从不间断的学习；有趣的灵魂，一定拥有乐观和豁达，不以物喜，不以己悲，不因挫折一蹶不振”</p>\n</li>\n</ul>\n<p><img src=\"https://i.328888.xyz/2023/05/07/i1Ai7x.jpeg\" alt=\"i1Ai7x.jpeg\"></p>\n"},{"title":"Rust 高性能原因解析","date":"2025-03-24T10:07:56.000Z","_content":"\n> 你不需要的东西，你不必复出代价。进一步说，你确实需要的东西，你也不必付出代价。\n\nRust高性能的原因剖析，从零成本抽象、无GC、编译器优化和编码思维这四个方面进行阐述：\n\n### 1. 零成本抽象\n\n- **高级抽象无性能开销**：Rust的零成本抽象理念，允许开发者利用高级抽象编写代码，这些代码在编译时能够转换成与手写C/C++代码同样高效的机器代码。这些高级功能的运行时开销极小甚至没有。\n\n- **泛型和trait的高效实现**：通过使用泛型和trait，可以编写可重用的代码，而不需要为每个具体类型编写重复的代码。这有助于减少代码重复和提高代码的可维护性，同时不会引入额外的性能开销。\n\n- **静态分派优化**：Rust支持静态分派，编译器在编译时就能确定函数调用的具体地址，减少了运行时的开销，提高了程序的性能。\n\n### 2. 无GC\n\n- **避免垃圾收集器的性能影响**：Rust不依赖垃圾收集器（GC）来管理内存，而是通过所有权和借用规则在编译时确保内存安全。这样避免了GC可能导致的程序执行中的不可预测暂停，使得内存管理在编译时就变得可预测。\n\n- **内存管理的高效性**：Rust的所有权模型可以在编译时捕捉大多数内存错误，从而减少运行时错误。这种机制不仅提高了程序的可靠性，还避免了因内存管理问题导致的性能损失。\n\n- **内存布局的优化**：Rust的编译器能够根据程序的需求，对内存布局进行优化，以减少内存碎片和提高内存访问的效率。这使得Rust在内存管理方面具有较高的性能。\n\n### 3. 编译器优化\n\nRust 采用了 LLVM 作为其编译器后端，这意味着 Rust 代码可以被编译成高效的机器码。LLVM 是一个开源的编译器基础设施项目，它提供了一套编译器技术，模块化，可重用的工具链和库，用于优化和生成高质量的机器码。\n\n- **高效的编译器**：Rust的编译器进行了大量的优化，包括内联、常量传播、死代码消除等。这些优化能够减少生成的代码的体积，提高程序的运行效率。\n\n- **代码生成的优化**：Rust的编译器能够根据标准化的接口定义生成最优的代码，从而减少不必要的开销。这意味着在实现抽象时，不会引入任何额外的开销，即使对于不使用抽象的代码也不会产生负担。\n\n### 4. 编码思维\n\n- **性能意识的开发习惯**：Rust的开发者通常具有较强的性能意识，在编码过程中会主动考虑如何编写高效的代码。例如，合理使用类型系统和所有权模型，避免不必要的内存分配和复制操作。\n- **安全与性能的平衡**：Rust的编码思维强调在保证内存安全的同时追求高性能。开发者在编写代码时，会充分利用Rust提供的各种特性，如模式匹配、枚举类型等，以实现既安全又高效的代码。\n- **模块化和可复用性**：Rust的零成本抽象和强大的类型系统支持模块化编程，使得开发者能够编写出更加模块化和可复用的代码库。这不仅提高了开发效率，还便于代码的维护和优化。\n\n综上，我们可以看到，Rust之所以能够实现高性能，得益于其零成本抽象的设计理念、无GC的内存管理机制、强大的编译器优化能力以及开发者注重性能的编码思维。这些因素共同作用，使得Rust在保证内存安全的同时，能够提供与C/C++相媲美的高性能表现。","source":"_posts/Rust-高性能原因解析.md","raw":"---\ntitle: Rust 高性能原因解析\ndate: 2025-03-24 18:07:56\ntags: rust\ncategories: 博客\n---\n\n> 你不需要的东西，你不必复出代价。进一步说，你确实需要的东西，你也不必付出代价。\n\nRust高性能的原因剖析，从零成本抽象、无GC、编译器优化和编码思维这四个方面进行阐述：\n\n### 1. 零成本抽象\n\n- **高级抽象无性能开销**：Rust的零成本抽象理念，允许开发者利用高级抽象编写代码，这些代码在编译时能够转换成与手写C/C++代码同样高效的机器代码。这些高级功能的运行时开销极小甚至没有。\n\n- **泛型和trait的高效实现**：通过使用泛型和trait，可以编写可重用的代码，而不需要为每个具体类型编写重复的代码。这有助于减少代码重复和提高代码的可维护性，同时不会引入额外的性能开销。\n\n- **静态分派优化**：Rust支持静态分派，编译器在编译时就能确定函数调用的具体地址，减少了运行时的开销，提高了程序的性能。\n\n### 2. 无GC\n\n- **避免垃圾收集器的性能影响**：Rust不依赖垃圾收集器（GC）来管理内存，而是通过所有权和借用规则在编译时确保内存安全。这样避免了GC可能导致的程序执行中的不可预测暂停，使得内存管理在编译时就变得可预测。\n\n- **内存管理的高效性**：Rust的所有权模型可以在编译时捕捉大多数内存错误，从而减少运行时错误。这种机制不仅提高了程序的可靠性，还避免了因内存管理问题导致的性能损失。\n\n- **内存布局的优化**：Rust的编译器能够根据程序的需求，对内存布局进行优化，以减少内存碎片和提高内存访问的效率。这使得Rust在内存管理方面具有较高的性能。\n\n### 3. 编译器优化\n\nRust 采用了 LLVM 作为其编译器后端，这意味着 Rust 代码可以被编译成高效的机器码。LLVM 是一个开源的编译器基础设施项目，它提供了一套编译器技术，模块化，可重用的工具链和库，用于优化和生成高质量的机器码。\n\n- **高效的编译器**：Rust的编译器进行了大量的优化，包括内联、常量传播、死代码消除等。这些优化能够减少生成的代码的体积，提高程序的运行效率。\n\n- **代码生成的优化**：Rust的编译器能够根据标准化的接口定义生成最优的代码，从而减少不必要的开销。这意味着在实现抽象时，不会引入任何额外的开销，即使对于不使用抽象的代码也不会产生负担。\n\n### 4. 编码思维\n\n- **性能意识的开发习惯**：Rust的开发者通常具有较强的性能意识，在编码过程中会主动考虑如何编写高效的代码。例如，合理使用类型系统和所有权模型，避免不必要的内存分配和复制操作。\n- **安全与性能的平衡**：Rust的编码思维强调在保证内存安全的同时追求高性能。开发者在编写代码时，会充分利用Rust提供的各种特性，如模式匹配、枚举类型等，以实现既安全又高效的代码。\n- **模块化和可复用性**：Rust的零成本抽象和强大的类型系统支持模块化编程，使得开发者能够编写出更加模块化和可复用的代码库。这不仅提高了开发效率，还便于代码的维护和优化。\n\n综上，我们可以看到，Rust之所以能够实现高性能，得益于其零成本抽象的设计理念、无GC的内存管理机制、强大的编译器优化能力以及开发者注重性能的编码思维。这些因素共同作用，使得Rust在保证内存安全的同时，能够提供与C/C++相媲美的高性能表现。","slug":"Rust-高性能原因解析","published":1,"updated":"2025-03-24T10:12:38.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm8mwrp8r00005f6cddys5m20","content":"<blockquote>\n<p>你不需要的东西，你不必复出代价。进一步说，你确实需要的东西，你也不必付出代价。</p>\n</blockquote>\n<p>Rust高性能的原因剖析，从零成本抽象、无GC、编译器优化和编码思维这四个方面进行阐述：</p>\n<h3 id=\"1-零成本抽象\"><a href=\"#1-零成本抽象\" class=\"headerlink\" title=\"1. 零成本抽象\"></a>1. 零成本抽象</h3><ul>\n<li><p><strong>高级抽象无性能开销</strong>：Rust的零成本抽象理念，允许开发者利用高级抽象编写代码，这些代码在编译时能够转换成与手写C&#x2F;C++代码同样高效的机器代码。这些高级功能的运行时开销极小甚至没有。</p>\n</li>\n<li><p><strong>泛型和trait的高效实现</strong>：通过使用泛型和trait，可以编写可重用的代码，而不需要为每个具体类型编写重复的代码。这有助于减少代码重复和提高代码的可维护性，同时不会引入额外的性能开销。</p>\n</li>\n<li><p><strong>静态分派优化</strong>：Rust支持静态分派，编译器在编译时就能确定函数调用的具体地址，减少了运行时的开销，提高了程序的性能。</p>\n</li>\n</ul>\n<h3 id=\"2-无GC\"><a href=\"#2-无GC\" class=\"headerlink\" title=\"2. 无GC\"></a>2. 无GC</h3><ul>\n<li><p><strong>避免垃圾收集器的性能影响</strong>：Rust不依赖垃圾收集器（GC）来管理内存，而是通过所有权和借用规则在编译时确保内存安全。这样避免了GC可能导致的程序执行中的不可预测暂停，使得内存管理在编译时就变得可预测。</p>\n</li>\n<li><p><strong>内存管理的高效性</strong>：Rust的所有权模型可以在编译时捕捉大多数内存错误，从而减少运行时错误。这种机制不仅提高了程序的可靠性，还避免了因内存管理问题导致的性能损失。</p>\n</li>\n<li><p><strong>内存布局的优化</strong>：Rust的编译器能够根据程序的需求，对内存布局进行优化，以减少内存碎片和提高内存访问的效率。这使得Rust在内存管理方面具有较高的性能。</p>\n</li>\n</ul>\n<h3 id=\"3-编译器优化\"><a href=\"#3-编译器优化\" class=\"headerlink\" title=\"3. 编译器优化\"></a>3. 编译器优化</h3><p>Rust 采用了 LLVM 作为其编译器后端，这意味着 Rust 代码可以被编译成高效的机器码。LLVM 是一个开源的编译器基础设施项目，它提供了一套编译器技术，模块化，可重用的工具链和库，用于优化和生成高质量的机器码。</p>\n<ul>\n<li><p><strong>高效的编译器</strong>：Rust的编译器进行了大量的优化，包括内联、常量传播、死代码消除等。这些优化能够减少生成的代码的体积，提高程序的运行效率。</p>\n</li>\n<li><p><strong>代码生成的优化</strong>：Rust的编译器能够根据标准化的接口定义生成最优的代码，从而减少不必要的开销。这意味着在实现抽象时，不会引入任何额外的开销，即使对于不使用抽象的代码也不会产生负担。</p>\n</li>\n</ul>\n<h3 id=\"4-编码思维\"><a href=\"#4-编码思维\" class=\"headerlink\" title=\"4. 编码思维\"></a>4. 编码思维</h3><ul>\n<li><strong>性能意识的开发习惯</strong>：Rust的开发者通常具有较强的性能意识，在编码过程中会主动考虑如何编写高效的代码。例如，合理使用类型系统和所有权模型，避免不必要的内存分配和复制操作。</li>\n<li><strong>安全与性能的平衡</strong>：Rust的编码思维强调在保证内存安全的同时追求高性能。开发者在编写代码时，会充分利用Rust提供的各种特性，如模式匹配、枚举类型等，以实现既安全又高效的代码。</li>\n<li><strong>模块化和可复用性</strong>：Rust的零成本抽象和强大的类型系统支持模块化编程，使得开发者能够编写出更加模块化和可复用的代码库。这不仅提高了开发效率，还便于代码的维护和优化。</li>\n</ul>\n<p>综上，我们可以看到，Rust之所以能够实现高性能，得益于其零成本抽象的设计理念、无GC的内存管理机制、强大的编译器优化能力以及开发者注重性能的编码思维。这些因素共同作用，使得Rust在保证内存安全的同时，能够提供与C&#x2F;C++相媲美的高性能表现。</p>\n","site":{"data":{"languages":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}},"excerpt":"","more":"<blockquote>\n<p>你不需要的东西，你不必复出代价。进一步说，你确实需要的东西，你也不必付出代价。</p>\n</blockquote>\n<p>Rust高性能的原因剖析，从零成本抽象、无GC、编译器优化和编码思维这四个方面进行阐述：</p>\n<h3 id=\"1-零成本抽象\"><a href=\"#1-零成本抽象\" class=\"headerlink\" title=\"1. 零成本抽象\"></a>1. 零成本抽象</h3><ul>\n<li><p><strong>高级抽象无性能开销</strong>：Rust的零成本抽象理念，允许开发者利用高级抽象编写代码，这些代码在编译时能够转换成与手写C&#x2F;C++代码同样高效的机器代码。这些高级功能的运行时开销极小甚至没有。</p>\n</li>\n<li><p><strong>泛型和trait的高效实现</strong>：通过使用泛型和trait，可以编写可重用的代码，而不需要为每个具体类型编写重复的代码。这有助于减少代码重复和提高代码的可维护性，同时不会引入额外的性能开销。</p>\n</li>\n<li><p><strong>静态分派优化</strong>：Rust支持静态分派，编译器在编译时就能确定函数调用的具体地址，减少了运行时的开销，提高了程序的性能。</p>\n</li>\n</ul>\n<h3 id=\"2-无GC\"><a href=\"#2-无GC\" class=\"headerlink\" title=\"2. 无GC\"></a>2. 无GC</h3><ul>\n<li><p><strong>避免垃圾收集器的性能影响</strong>：Rust不依赖垃圾收集器（GC）来管理内存，而是通过所有权和借用规则在编译时确保内存安全。这样避免了GC可能导致的程序执行中的不可预测暂停，使得内存管理在编译时就变得可预测。</p>\n</li>\n<li><p><strong>内存管理的高效性</strong>：Rust的所有权模型可以在编译时捕捉大多数内存错误，从而减少运行时错误。这种机制不仅提高了程序的可靠性，还避免了因内存管理问题导致的性能损失。</p>\n</li>\n<li><p><strong>内存布局的优化</strong>：Rust的编译器能够根据程序的需求，对内存布局进行优化，以减少内存碎片和提高内存访问的效率。这使得Rust在内存管理方面具有较高的性能。</p>\n</li>\n</ul>\n<h3 id=\"3-编译器优化\"><a href=\"#3-编译器优化\" class=\"headerlink\" title=\"3. 编译器优化\"></a>3. 编译器优化</h3><p>Rust 采用了 LLVM 作为其编译器后端，这意味着 Rust 代码可以被编译成高效的机器码。LLVM 是一个开源的编译器基础设施项目，它提供了一套编译器技术，模块化，可重用的工具链和库，用于优化和生成高质量的机器码。</p>\n<ul>\n<li><p><strong>高效的编译器</strong>：Rust的编译器进行了大量的优化，包括内联、常量传播、死代码消除等。这些优化能够减少生成的代码的体积，提高程序的运行效率。</p>\n</li>\n<li><p><strong>代码生成的优化</strong>：Rust的编译器能够根据标准化的接口定义生成最优的代码，从而减少不必要的开销。这意味着在实现抽象时，不会引入任何额外的开销，即使对于不使用抽象的代码也不会产生负担。</p>\n</li>\n</ul>\n<h3 id=\"4-编码思维\"><a href=\"#4-编码思维\" class=\"headerlink\" title=\"4. 编码思维\"></a>4. 编码思维</h3><ul>\n<li><strong>性能意识的开发习惯</strong>：Rust的开发者通常具有较强的性能意识，在编码过程中会主动考虑如何编写高效的代码。例如，合理使用类型系统和所有权模型，避免不必要的内存分配和复制操作。</li>\n<li><strong>安全与性能的平衡</strong>：Rust的编码思维强调在保证内存安全的同时追求高性能。开发者在编写代码时，会充分利用Rust提供的各种特性，如模式匹配、枚举类型等，以实现既安全又高效的代码。</li>\n<li><strong>模块化和可复用性</strong>：Rust的零成本抽象和强大的类型系统支持模块化编程，使得开发者能够编写出更加模块化和可复用的代码库。这不仅提高了开发效率，还便于代码的维护和优化。</li>\n</ul>\n<p>综上，我们可以看到，Rust之所以能够实现高性能，得益于其零成本抽象的设计理念、无GC的内存管理机制、强大的编译器优化能力以及开发者注重性能的编码思维。这些因素共同作用，使得Rust在保证内存安全的同时，能够提供与C&#x2F;C++相媲美的高性能表现。</p>\n"},{"title":"Golang 并发编程实战总结","date":"2025-03-28T08:12:34.000Z","_content":"\n# Golang 并发编程实践总结\n\n目录\n- [Golang 并发编程实践总结](#golang-并发编程实践总结)\n  - [深⼊理解GMP模型](#深⼊理解GMP模型)\n  - [Channel是什么](#Channel是什么？什么作用？底层数据结构是什么？)\n  - [Select的用法](#Select的用法)\n  - [使用sync包](#使用sync包)\n  - [WaitGroup](#WaitGroup)\n  - [Pool](#Pool)\n  - [常见内存泄露及注意事项](#常见内存泄露及注意事项)\n\n# 深⼊理解GMP模型\n\n**【思考🤔】⾸先思考⼀个问题为什么需要协程？**\n\n其实答案也很明显：在多进程和多线程时代，CPU 内核负责调度，为系统提供并发处理能⼒，但也存在⼀些缺点：\n\n- 资源消耗⾼：进程和线程的创建、切换和销毁都会消耗⼤量 CPU 资源。\n\n- 内存占⽤⼤：每个线程约需 4MB 内存，⼤量线程会导致内存消耗过⾼。\n\n- 应⽤层⽆法直接控制内核调度，只能通过减少线程创建和切换来优化性能。\n\n这促⽣了协程的概念：⽤户级别的轻量线程。在 Go 中，协程被称为 `goroutine`，它主要解决了内核线程的两个“太重”问题：\n\n- 创建和切换：`goroutine`  在⽤户态创建和切换，⽆需进⼊内核，开销⽐线程⼩得多。\n- 内存占⽤：`goroutine`  的初始栈只有 2KB，栈空间可动态扩展或收缩，避免了内存浪费与栈溢出⻛险。\n- 由于 `goroutine`  的轻量特性，Go 程序可以轻松创建成千上万个并发任务，⽽不⽤担⼼性能和内存问题。\n\n\n\n**【思考🤔 】第⼆个问题：**golang **可以在⽤户级别空间创建协程底层是靠什么实现的**?\n\n其实是虽然协程在⽤户态空间运⾏，但其底层实现依赖于Go运⾏时对操作系统线程（OS Threads）的管理和调度。\n\n具体来说：Go 协程运⾏在⽤户态空间，但它们并不是直接由操作系统调度的线程。相反，**Go **运⾏时通过⼀个⽤户态的调度器（**Scheduler**）来管理协程的执⾏，并将协程映射到操作系统线程上。\n\n- ⽤户态协程（Goroutine）：轻量级的并发单元，由Go运⾏时管理。\n- 操作系统线程（OS Thread）：由操作系统调度的线程，⽤于执⾏Go运⾏时的代码。\n- 运⾏时调度器（Scheduler）：负责将协程分配到操作系统线程上执⾏。\n\nGo 运⾏时的调度器是协程实现的核⼼，它通过以下组件协同⼯作：\n\n- G（goroutine）：\n  - 是⽤户态线程的抽象，可以在 M 上运⾏，存储于全局队列和 P 的本地队列（⼤⼩ 256）中。\n  - **特点：**G是轻量级的，创建和销毁的开销极⼩。\n- M（Machine）：\n  - 是操作系统线程的抽象，⼀个 M 代表⼀个线程，最多绑定⼀个 P。M 阻塞时会释放 P，允许 P与其他空闲的 M 绑定，如果没有空闲的 M，则创建新的 M。\n  - **特点：**M的数量通常远少于G的数量，由Go运⾏时动态管理。\n- P（Processor）：\n  - 逻辑处理器，抽象代表 CPU 核⼼。P 的数量决定了程序的并⾏能⼒，可以通过 GOMAXPROCS 设置。每个 M 需要绑定⼀个 P 进⾏任务调度。是 M 和 G 之间的桥梁。每个 P 都有⼀个本地的 Goroutine 队列，同时也可以访问全局的 Goroutine 队列。P 负责调度和管理 Goroutine 的执⾏，决定哪个 Goroutine 应该在哪个 M 上运⾏。\n  - **特点：** P的数量通常与CPU核⼼数相匹配，⽤于充分利⽤多核CPU的计算能⼒。\n\nGo运⾏时的调度器通过以下步骤管理协程的执⾏：\n\n- 创建协程：当调⽤go func()时，Go运⾏时会创建⼀个新的G，并将其加⼊到调度队列中。\n- 调度协程：调度器从队列中取出G，并将其分配给⼀个P。P将G绑定到⼀个M上，M开始执⾏G中的代码。\n\n阻塞与唤醒\n\n- 如果G在执⾏过程中阻塞（如等待I/O操作），调度器会将该G挂起，并从队列中取出另⼀个G继续执⾏。\n- 当阻塞的G被唤醒时，调度器会将其重新加⼊到队列中，等待执⾏。\n\n线程复⽤：\n\n- 如果所有M都被阻塞，调度器会创建新的M来执⾏队列中的G。\n- 如果某个M完成任务，调度器会将该M回收，⽤于执⾏其他G。\n\nGMP 模型引⼊了 P 来解决 GM 模型的缺陷：\n\n- ⽆锁访问本地队列：P 保存 goroutine 的本地队列，M 优先从 P 的本地队列中取 G 执⾏，仅必要时访问全局队列，减少了锁竞争，提升了并发性。\n- 优化数据局部性：新创建的 G 会优先放⼊创建它的 M 绑定的 P 的本地队列中，避免频繁的数据交互，提升内存使⽤效率。\n- Hand Off 交接机制：M 阻塞时，将绑定的 P 和其任务交给其他 M，提升了资源利⽤率和并发度。\n\nGMP 调度时机：介绍 GMP 的调度时机，主要分为正常调度、主动调度、被动调度和抢占调度四种情况\n\n具体调度过程\n\n- **创建** Goroutine：当使⽤ go 关键字创建⼀个新的 Goroutine 时，Go 运⾏时会为其分配⼀个 G 对象，并将其放⼊全局或某个 P 的本地 Goroutine 队列中。\n\n- **调度** Goroutine **到** M **上执⾏**：M 会从 P 的本地队列或全局队列中获取⼀个 G，并将其绑定到⾃⼰身上执⾏。如果 P 的本地队列为空，M 会尝试从其他 P 的本地队列中 “偷取” ⼀些 G 来执⾏，这种机制称为 “⼯作窃取”，可以提⾼调度的效率。\n\n- **阻塞和唤醒**：当⼀个 Goroutine 遇到阻塞操作（如 I/O 操作、Channel 读写等）时，M 会将该 G 标记为阻塞状**阻塞和唤醒**：当⼀个 Goroutine 遇到阻塞操作（如 I/O 操作、Channel 读写等）时，M 会将该 G 标记为阻塞状态，并将其从当前 P 的队列中移除。同时，M 会继续从队列中获取其他 G 来执⾏。当阻塞操作完成后，G 会被唤醒，并重新放⼊某个 P 的队列中等待调度。\n\n- **上下⽂切换**：Goroutine 的上下⽂切换由 Go 运⾏时负责，⽽不是操作系统内核。这种⽤户态的上下⽂切换⽐内核态的上下⽂切换开销⼩得多，因此可以实现⾼效的并发调度。\n\n\n\n# Channel是什么？什么作用？底层数据结构是什么？\n\n## Channel 的作用\n\n在 Golang 并发编程中，channel（通道）是一种用于 goroutine 之间通信和同步的机制。它的主要作用包括：\n\n1. **goroutine 间通信**：channel 允许不同的 goroutine 之间传递数据，实现数据的共享和交换。\n2. **goroutine 同步**：通过 channel 可以控制 goroutine 的执行顺序，实现对并发操作的同步。\n\n## Channel 的底层原理\n\n```go\ntype hchan struct {\n\n  qcount uint // 当前缓冲区中的元素数量\n\n  dataqsiz buf uint unsafe.Pointer // 缓冲区⼤⼩（⽆缓冲区时为 0）\n\n  // 指向缓冲区的指针\n\n  elemsize uint16 // 元素⼤⼩\n\n  closed uint32 // 标记通道是否已关闭\n\n  sendx uint // 下⼀个发送操作的索引\n\n  recvx uint // 下⼀个接收操作的索引\n\n  recvq waitq // 等待接收的协程队列\n\n  sendq waitq // 等待发送的协程队列\n\n  lock mutex // 互斥锁，⽤于保护并发操作\n}\n\n\n```\n\nbuf 指向底层循环数组，只有缓冲型的 channel 才有。⽆缓冲区的通道则直接在发送和接收操作之间传递数据。\n\n sendx， recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。\n\n sendq， recvq 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据⽽被阻\n\n  塞。\n\nwaitq 是 sudog 的⼀个双向链表，⽽ sudog 实际上是对 goroutine 的⼀个封装：\n\n```go\ntype waitq struct {\n\n  first *sudog\n\n  last *sudog\n\n}\n```\n\nlock ⽤来保证每个读 channel 或写 channel 的操作都是原⼦的。\n\n- **⽆缓冲区通道**： dataqsiz 为 0，发送和接收操作必须同步完成。如果发送⽅没有接收⽅，发送⽅会阻塞，反之\n\n亦然。\n\n- **有缓冲区通道**： dataqsiz ⼤于 0，发送⽅可以将数据写⼊缓冲区，接收⽅可以从缓冲区读取数据。当缓冲区满\n\n时，发送⽅阻塞；当缓冲区为空时，接收⽅阻塞。\n\nhchan 使⽤互斥锁（ mutex）来保护对缓冲区和协程队列的访问，确保在并发操作时不会出现数据竞争。通过这些底层结构和机制， channel 实现了⾼效且安全的协程间通信。\n\n在 Golang 中，channel 可以分为无缓冲 channel 和有缓冲 channel，它们的主要区别在于通信方式和使用场景。以下是两者的通俗理解和具体区别：\n\n## 通俗理解无缓冲和有缓冲\n\n**无缓冲 channel（同步 channel）**\n\n- 无缓冲 channel 就像两个人直接进行面对面的交流。\n- 发送方和接收方必须同时准备好，才能进行数据传递。\n- 如果发送方先到，它会一直等待接收方到来；如果接收方先到，它会一直等待发送方发送数据。\n- 无缓冲 channel 的发送和接收操作是同步的，会阻塞直到双方都准备好。\n\n**有缓冲 channel（异步 channel）**\n\n- 有缓冲 channel 就像一个快递柜，发送方可以先把东西放在快递柜里，接收方可以在有空的时候来取。\n- 发送方在缓冲区有空位时可以直接把数据放进去，不需要等待接收方。\n- 接收方在缓冲区有数据时可以直接取出来，不需要等待发送方。\n- 有缓冲 channel 的发送和接收操作在缓冲区有空间或数据时可以异步进行，只有在缓冲区满或空时才会阻塞。\n\n使用场景\n\n**无缓冲 channel**\n\n- 当需要严格同步两个 goroutine 的执行顺序时。\n- 当需要确保发送方和接收方同时参与通信时。\n\n**有缓冲 channel**\n\n- 当需要解耦发送和接收操作时。\n- 当需要暂存数据，避免发送方或接收方阻塞时。\n\n\n\n# Select的用法\n\nSelect 用来处理一个 Goroutine 等待多个 Channel 的情况。类似于 Switch 语句，Select 的每个 case 都是一个通信操作（发送或接收），当有 case 满足条件的时候，则执行对应 case 块的代码。\n\n当没有 case 满足的时候，Select 逻辑块也会阻塞程序，当有多个 case 满足的时候，Select 会公平选择一个满足条件的 case 语句块执行（GO1.8 之后会随机选择一个）。为了避免阻塞，可以使用 default 。\n\n在 Golang 并发编程中，`select` 语句用于处理多个 channel 的通信。它允许程序同时监听多个 channel 上的通信操作，并根据哪个操作最先完成来执行相应的代码块。`select` 语句在处理多个并发通信时非常有用，可以实现多路复用。\n\n## 关键点\n\n1. **多路复用**：`select` 会同时监听多个 channel 上的通信操作。\n2. **随机选择**：如果有多个通信操作同时可以执行，`select` 会随机选择一个执行。\n3. **阻塞**：如果没有通信操作可以立即执行且没有默认分支，`select` 会阻塞，直到至少有一个通信操作可以执行。\n4. **默认分支**：如果有默认分支，当没有通信操作可以立即执行时，会执行默认分支的代码。\n\n## 注意事项\n\n1. **随机选择**：当多个 `case` 同时满足时，`select` 会随机选择一个执行，无法预测具体是哪一个。\n2. **阻塞**：如果没有 `default` 分支且没有通信操作可以立即执行，`select` 会阻塞。\n3. **死锁风险**：如果所有 `case` 都无法执行且没有 `default` 分支，程序可能会陷入死锁。\n4. **效率**：`select` 的效率较高，适合处理多个并发通信。\n\n\n\n\n\n# 使用sync包\n\nGolang 并发编程离不开 sync 包，里面提供了很多有用的类型和方法。常用知识点如下：\n\n## Map\n\n普通的 map 不是并发安全的，容易出现竞争问题。sync.Map 是官方提供的一个并发安全的 Map，不需要自己额外处理锁、协调等操作。该类型提供了以下方法：\n\n- Loads(): 装载键值（获取键值）\n- Store(): 储存键值\n- Delete(): 删除键值\n- LoadOrStore(): 如果存在则获取键值，不存在则存储\n- Range(): 遍历 Map\n\n\n\n## 相反，并发安全的数据有如下\n\n- sync.Map：通过读写 map来实现，读请求默认⾛读 map，如果读不到再请求写 map（加锁保证），同时在特定条件满⾜的情况下同步缓存和 DB 中的数据。misses 字段则⽤于计数，记录缓存未命中的次数，当我们要读取map 中某个 key 对应的值时，优先从 read 读取，如果 read 中不存在，则 misses 值加 1，然后继续从 dirty 中读取，当 misses 值达到某个阈值时，sync.Map 就会将 dirty 提升为 read。\n\n- sync.Pool是⼀个并发安全的临时对象池。它可以安全地被多个 goroutine 同时使⽤，⽤于缓存和复⽤临时对象，减少频繁创建和销毁对象带来的内存分配和垃圾回收压⼒，提⾼性能。\n- 原⼦类型包 sync/atomic 包;进⾏并发安全的操作。\n- 读写锁（ sync.RWMutex）包装的数据结构。\n\n- Mutex：互斥锁。对于加了锁的操作，其他的 Goroutine 在读取相应对象时会阻塞，知道互斥对象释放。频繁、大量的使用互斥锁会导致性能的降低，应该只在必须用的地方用。互斥锁使用不当还有可能造成死锁、活锁、饿死等情况，就比较复杂了。\n\n## `sync.Once`\n\n在 Golang 中，`sync.Once` 是一个用于确保某个函数或方法只被调用一次的工具。它在并发编程中非常有用，可以用来实现单例模式、资源初始化等场景，确保某些操作只执行一次，即使有多个 goroutine 同时尝试执行这些操作。\n\n### 基本用法\n\n`sync.Once` 提供了两个主要方法：\n\n1. **`Do(f func())`**：执行给定的函数 `f`，并且保证 `f` 只会被执行一次，即使有多个 goroutine 调用 `Do` 方法。\n2. **`Done() chan struct{}`**：返回一个通道，当 `Do` 方法完成时，该通道会关闭。可以用于等待 `Do` 方法的完成。\n\n示例代码\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var once sync.Once\n\n    // 定义一个需要只执行一次的函数\n    initFunc := func() {\n        fmt.Println(\"Initializing...\")\n    }\n\n    // 多个 goroutine 同时调用 once.Do\n    for i := 0; i < 5; i++ {\n        go func() {\n            once.Do(initFunc)\n        }()\n    }\n\n    // 等待所有 goroutine 完成\n    time.Sleep(100 * time.Millisecond)\n}\n```\n\n单例模式\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar (\n    instance *MySingleton\n    once     sync.Once\n)\n\ntype MySingleton struct{}\n\nfunc NewMySingleton() *MySingleton {\n    once.Do(func() {\n        instance = &MySingleton{}\n        fmt.Println(\"Singleton instance created\")\n    })\n    return instance\n}\n\nfunc main() {\n    // 多个 goroutine 同时获取单例实例\n    for i := 0; i < 5; i++ {\n        go func() {\n            singleton := NewMySingleton()\n            fmt.Println(\"Got singleton instance:\", singleton)\n        }()\n    }\n\n    // 等待所有 goroutine 完成\n    time.Sleep(100 * time.Millisecond)\n}\n```\n\n输出：\n\n```go\nSingleton instance created\nGot singleton instance: &{{}}\nGot singleton instance: &{{}}\nGot singleton instance: &{{}}\nGot singleton instance: &{{}}\nGot singleton instance: &{{}}\n```\n\n### 注意事项\n\n1. **线程安全性**：`sync.Once` 是线程安全的，可以安全地在多个 goroutine 中使用。\n2. **函数执行**：`Do` 方法中的函数只会被执行一次，即使有多个 goroutine 同时调用 `Do` 方法。\n3. **不可重置**：`sync.Once` 不能被重置，一旦执行完成，无法再次执行。\n\n`sync.Once` 是 Golang 并发编程中一个非常有用的工具，用于确保某个函数或方法只被调用一次。它在实现单例模式、资源初始化等场景中非常有用，可以简化代码并提高程序的可靠性。\n\n\n\n## 前言\n\n最近的项目都使用 Golang 进行开发，因为自己是从头自学，难免踩了很多坑。目前项目接近尾声，抽空对一些重要的知识点做一些总结。\n\n## Goroutine 与 Channel\n\n什么是 Goroutine 呢？有人说它是轻量级的进程，或者干脆说是协程。其实都不太准确，协程仅仅是在一个进程中进行子程序的切换，而 Goroutine 是可以多线程多路复用的。简而言之，Goroutine 是一个轻量级的、与其他 Goroutine 运行在同一块内存地址中的并发执行的函数模型。它的成本仅仅比堆栈的分配高一点点，所以很廉价。Goroutine 可以在多个线程上通过 Goroutine 自己的调度器实现多路复用。\n\n那什么是 Channel 呢？它是程序中一种类型化的通道，即在这个虚拟通道中传输的是某种预定义的数据类型。通过相应的操作符如 `<-` 可以在 Goroutine 之间发送和接收数据。 Channel 在默认情况下，接收或者发送的某端没有执行的时候会阻塞程序。Channel 可以在创建时定义缓冲大小，即缓冲区已满时才会发送缓存区的所有数据。\n\nChannel 最简单的用法就是利用其阻塞程序的特性来做 Goroutine 结束的标志。例如在 Goroutine 代码块外定义一个 Channel 接收其中的数据，当 Goroutine 代码块内部执行完毕时向 Channel 发送完成信号进而执行后续的代码。\n\n当程序有多个 Goroutine 或者多个 Channel ，他们管理起来就容易变得混乱。这时就可以考虑使用下文讲到的知识。\n\n## Select 的用法\n\nSelect 用来处理一个 Goroutine 等待多个 Channel 的情况。类似于 Switch 语句，Select 的每个 case 都是一个通信操作（发送或接收），当有 case 满足条件的时候，则执行对应 case 块的代码。当没有 case 满足的时候，Select 逻辑块也会阻塞程序，当有多个 case 满足的时候，Select 会公平选择一个满足条件的 case 语句块执行。为了避免阻塞，可以使用 default 。\n\n## 使用 sync 包\n\nGolang 并发编程离不开 sync 包，里面提供了很多有用的类型和方法。常用知识点如下：\n\n### Map\n\n普通的 map 不是并发安全的，容易出现竞争问题。sync.Map 是官方提供的一个并发安全的 Map，不需要自己额外处理锁、协调等操作。该类型提供了以下方法：\n\n- Loads(): 装载键值（获取键值）\n- Store(): 储存键值\n- Delete(): 删除键值\n- LoadOrStore(): 如果存在则获取键值，不存在则存储\n- Range(): 遍历 Map\n\n我在项目中使用该类型替代了自己原本定义的一个全局 Map 类型，相比自己维护互斥锁或者读写锁等操作方便了不少，而且性能有优势（具体没有测试），据官方说明该 Map 类型显著减少了锁的争用。\n\n### Mutex\n\n互斥锁。对于加了锁的操作，其他的 Goroutine 在读取相应对象时会阻塞，知道互斥对象释放。频繁、大量的使用互斥锁会导致性能的降低，应该只在必须用的地方用。互斥锁使用不当还有可能造成死锁、活锁、饿死等情况，就比较复杂了。\n\n### RWMutex\n\n读写锁。相较互斥锁，读写锁相较互斥锁性能损耗低些，因为对于只读操作只加共享锁，是支持并发的，仅在写操作上加互斥锁，明显提升了效率。\n\n### Once\n\nOnce 这个对象很有用，它是一个只执行一个操作的对象。该对象仅有一个 Do() 方法，仅当 Once 实例第一次调用 Do() 方法时，Do() 才会调用传递过来的函数。\n\n这对于要实现单例模式的代码会方便一些，定义一个 Once 对象，将要实现单例的对象的初始化方法传递给 Do()，就能保证单例的并发安全。\n\n但使用互斥锁不也能解决这个问题吗？其实不然，互斥锁的代价太高，会导致 Goroutines 无法对该变量进行并发访问。那我把它改成读写锁呢？例如：\n\n```\nvar mu sync.RWMutex // 定义读写锁\nvar someMap map[string]interface{}\n\n// 并发安全的单例\nfunc GetMap(name string) interface{} {\n    // 加读锁，并判断 someMap 是否为空\n    // 如果不为空则获取 Map 中的值\n    mu.RLock()\n    if someMap != nil {\n        foo := someMap[name]\n        mu.RUnlock()\n        return foo\n    }\n    // 注意这里无法在 else 语句将共享锁升级为互斥锁\n    mu.RUnlock()\n\n    // 如果 someMap 为空加互斥锁，并初始化 someMap\n    mu.Lock()\n\n    // 注意：必须要再一次检查是否为 nil\n    if someMap == nil { \n        CreateMap()\n    }\n    foo := someMap[name]\n    mu.Unlock()\n    return foo\n}\n```\n\n然而这种方式不觉得太复杂了吗？\n\n# Pool\n\nPool 是一组用来保存或者检索的临时对象。Pub() 方法的入参是空接口，意味着可以把任何类型的对象放置在池子中以复用，减轻垃圾回收器的压力，正确的使用能很轻松的构建高效、线程安全的自由列表。\n\n# WaitGroup\n\nWaitGroup 适用于等待多个 Goroutine 完成的逻辑下使用，控制多个 Goroutine 之间的同步。每新建一个 Goroutine 就可以调用 WaitGroup.Add() 来增加需要等待的 Goroutine 数量，当每个 Goroutine 都运行完毕时各自调用 Done() ，可以在程序的外层调用 Wait() 以阻塞程序直到所有 Goroutine 都调用了 Done()。\n\n这样就可以在程序中使每个 WaitGroup 之间是同步的，但是 WaitGroup 之内的 Goroutine 是异步的。\n\n# Context\n\n与 WaitGroup 不同，Context 实现了对串行的 Goroutine 的跟踪和控制，比如一个 Goroutine 在运行过程中派生出了其他 Goroutine，这些派生出的 Goroutine 又派生出了其他 Goroutine，这种 Goroutine 的关系链使用之前的 Channel + Select 来维护会使得程序变得异常复杂。而使用 Context 上下文来实现 Goroutine 间截止时间、取消信号或其他变量的共享和传递会变得简单。\n\nContext 有四种方法来派生出不同的上下文：\n\n- WithCancel: 传递取消信号\n- WithDeadline: 传递截止时间\n- WithTimeout: 传递超时信号\n- WithValue: 传递其他值\n\n例如 WithCancel 派生出的上下文，在对应 Goroutine 中调用 cancel() 会使所有同一上下文派生出的所有 Goroutine 关闭，在派生出的 Goroutine 中可以通过监听 ctx.Done() 来判断是否关闭 Goroutine。\n\nContext 还有许多其他的用途，在 gRPC 、gin 中大量运用了 Context。Context 是并发安全的，所以可以放心的在 Goroutines 之间传递。\n\n在Golang并发编程中，内存泄露和一些注意事项是需要特别关注的，以下是常见的情况和建议：\n\n# 常见内存泄露及注意事项\n\n1. **goroutine泄露**\n   - **场景**：goroutine因阻塞（如未关闭的channel、死循环）无法退出，导致内存泄露。每个goroutine占用2KB内存，大量goroutine泄露会造成内存占用持续增加。\n   - **原因**：goroutine在执行时被阻塞而无法退出，如未关闭的channel导致接收方一直等待。\n   - **避免**：确保goroutine有明确的退出机制，如使用`context.Context`传递取消信号，关闭channel通知协程退出。\n\n2. **time.Ticker未关闭**\n   - **场景**：time.Ticker每间隔指定时间向通道写数据，若不调用`Stop()`方法，会一直占用内存。\n   - **避免**：在使用完time.Ticker后，务必调用`Stop()`方法来停止它。\n\n3. **字符串和切片截取**\n   - **场景**：长字符串或切片被截取后，如果截取的小部分还在活跃，原大块内存将无法被回收，导致临时内存泄露。\n   - **避免**：在不需要保留原大块内存时，可以复制需要的部分到新的变量，或者使用其他方式避免共享底层数组。\n\n4. **Finalizer导致泄漏**\n   - **场景**：设置Finalizer后，对象的内存无法被垃圾回收器及时回收，尤其当存在循环引用时。\n   - **避免**：谨慎使用Finalizer，避免不必要的循环引用。\n\n5. **Deferring Function Call导致泄漏**\n   - **场景**：大量文件打开后仅在函数结束时释放，造成临时内存泄露。\n   - **避免**：在循环中打开文件时，应立即关闭，而不是等待函数结束。\n\n6. **内存分配未释放**\n   - **场景**：持续分配内存但未释放，如持续向切片中添加数据而未清理。\n   - **避免**：合理管理内存分配和释放，避免不必要的内存堆积。\n\n7. **大数组作为参数**\n   - **场景**：大数组作为形参时，值拷贝导致内存使用激增。\n   - **避免**：对于大数组，使用切片或指针传递，减少内存占用。\n\n## 注意事项\n\n1. **并发安全与同步**\n   - 共享资源需用`sync.Mutex`、`sync.RWMutex`或原子操作保护，优先使用Channel传递数据，避免直接共享内存。\n\n2. **控制并发量**\n   - 避免无限制创建协程，使用带缓冲的Channel、Worker Pool或信号量限制并发数。\n\n3. **处理协程错误**\n   - 在goroutine内部使用`defer`+`recover`处理`panic`，避免整个程序崩溃。\n\n4. **避免Channel死锁**\n   - 确保Channel的发送和接收成对出现，避免协程永久阻塞，如未关闭的Channel可能导致接收方等待。\n\n5. **利用Context传递元数据和取消信号**\n   - 使用`context.Context`传递元数据和取消信号，方便控制goroutine的生命周期。\n\n6. **合理使用锁**\n   - 避免在持有锁的情况下调用可能导致阻塞的操作，如I/O操作，防止死锁。\n\n7. **监控和分析**\n   - 使用`runtime.MemStats`监控内存使用情况，使用`pprof`进行性能分析，及时发现和解决内存和性能问题。\n\n通过遵循以上建议和注意事项，可以有效避免Golang并发编程中的内存泄露问题，编写出高效、稳定的并发程序。","source":"_posts/Golang-并发编程实战总结.md","raw":"---\ntitle: Golang 并发编程实战总结\ndate: 2025-03-28 16:12:34\ntags: golang\ncategories: 博客\n---\n\n# Golang 并发编程实践总结\n\n目录\n- [Golang 并发编程实践总结](#golang-并发编程实践总结)\n  - [深⼊理解GMP模型](#深⼊理解GMP模型)\n  - [Channel是什么](#Channel是什么？什么作用？底层数据结构是什么？)\n  - [Select的用法](#Select的用法)\n  - [使用sync包](#使用sync包)\n  - [WaitGroup](#WaitGroup)\n  - [Pool](#Pool)\n  - [常见内存泄露及注意事项](#常见内存泄露及注意事项)\n\n# 深⼊理解GMP模型\n\n**【思考🤔】⾸先思考⼀个问题为什么需要协程？**\n\n其实答案也很明显：在多进程和多线程时代，CPU 内核负责调度，为系统提供并发处理能⼒，但也存在⼀些缺点：\n\n- 资源消耗⾼：进程和线程的创建、切换和销毁都会消耗⼤量 CPU 资源。\n\n- 内存占⽤⼤：每个线程约需 4MB 内存，⼤量线程会导致内存消耗过⾼。\n\n- 应⽤层⽆法直接控制内核调度，只能通过减少线程创建和切换来优化性能。\n\n这促⽣了协程的概念：⽤户级别的轻量线程。在 Go 中，协程被称为 `goroutine`，它主要解决了内核线程的两个“太重”问题：\n\n- 创建和切换：`goroutine`  在⽤户态创建和切换，⽆需进⼊内核，开销⽐线程⼩得多。\n- 内存占⽤：`goroutine`  的初始栈只有 2KB，栈空间可动态扩展或收缩，避免了内存浪费与栈溢出⻛险。\n- 由于 `goroutine`  的轻量特性，Go 程序可以轻松创建成千上万个并发任务，⽽不⽤担⼼性能和内存问题。\n\n\n\n**【思考🤔 】第⼆个问题：**golang **可以在⽤户级别空间创建协程底层是靠什么实现的**?\n\n其实是虽然协程在⽤户态空间运⾏，但其底层实现依赖于Go运⾏时对操作系统线程（OS Threads）的管理和调度。\n\n具体来说：Go 协程运⾏在⽤户态空间，但它们并不是直接由操作系统调度的线程。相反，**Go **运⾏时通过⼀个⽤户态的调度器（**Scheduler**）来管理协程的执⾏，并将协程映射到操作系统线程上。\n\n- ⽤户态协程（Goroutine）：轻量级的并发单元，由Go运⾏时管理。\n- 操作系统线程（OS Thread）：由操作系统调度的线程，⽤于执⾏Go运⾏时的代码。\n- 运⾏时调度器（Scheduler）：负责将协程分配到操作系统线程上执⾏。\n\nGo 运⾏时的调度器是协程实现的核⼼，它通过以下组件协同⼯作：\n\n- G（goroutine）：\n  - 是⽤户态线程的抽象，可以在 M 上运⾏，存储于全局队列和 P 的本地队列（⼤⼩ 256）中。\n  - **特点：**G是轻量级的，创建和销毁的开销极⼩。\n- M（Machine）：\n  - 是操作系统线程的抽象，⼀个 M 代表⼀个线程，最多绑定⼀个 P。M 阻塞时会释放 P，允许 P与其他空闲的 M 绑定，如果没有空闲的 M，则创建新的 M。\n  - **特点：**M的数量通常远少于G的数量，由Go运⾏时动态管理。\n- P（Processor）：\n  - 逻辑处理器，抽象代表 CPU 核⼼。P 的数量决定了程序的并⾏能⼒，可以通过 GOMAXPROCS 设置。每个 M 需要绑定⼀个 P 进⾏任务调度。是 M 和 G 之间的桥梁。每个 P 都有⼀个本地的 Goroutine 队列，同时也可以访问全局的 Goroutine 队列。P 负责调度和管理 Goroutine 的执⾏，决定哪个 Goroutine 应该在哪个 M 上运⾏。\n  - **特点：** P的数量通常与CPU核⼼数相匹配，⽤于充分利⽤多核CPU的计算能⼒。\n\nGo运⾏时的调度器通过以下步骤管理协程的执⾏：\n\n- 创建协程：当调⽤go func()时，Go运⾏时会创建⼀个新的G，并将其加⼊到调度队列中。\n- 调度协程：调度器从队列中取出G，并将其分配给⼀个P。P将G绑定到⼀个M上，M开始执⾏G中的代码。\n\n阻塞与唤醒\n\n- 如果G在执⾏过程中阻塞（如等待I/O操作），调度器会将该G挂起，并从队列中取出另⼀个G继续执⾏。\n- 当阻塞的G被唤醒时，调度器会将其重新加⼊到队列中，等待执⾏。\n\n线程复⽤：\n\n- 如果所有M都被阻塞，调度器会创建新的M来执⾏队列中的G。\n- 如果某个M完成任务，调度器会将该M回收，⽤于执⾏其他G。\n\nGMP 模型引⼊了 P 来解决 GM 模型的缺陷：\n\n- ⽆锁访问本地队列：P 保存 goroutine 的本地队列，M 优先从 P 的本地队列中取 G 执⾏，仅必要时访问全局队列，减少了锁竞争，提升了并发性。\n- 优化数据局部性：新创建的 G 会优先放⼊创建它的 M 绑定的 P 的本地队列中，避免频繁的数据交互，提升内存使⽤效率。\n- Hand Off 交接机制：M 阻塞时，将绑定的 P 和其任务交给其他 M，提升了资源利⽤率和并发度。\n\nGMP 调度时机：介绍 GMP 的调度时机，主要分为正常调度、主动调度、被动调度和抢占调度四种情况\n\n具体调度过程\n\n- **创建** Goroutine：当使⽤ go 关键字创建⼀个新的 Goroutine 时，Go 运⾏时会为其分配⼀个 G 对象，并将其放⼊全局或某个 P 的本地 Goroutine 队列中。\n\n- **调度** Goroutine **到** M **上执⾏**：M 会从 P 的本地队列或全局队列中获取⼀个 G，并将其绑定到⾃⼰身上执⾏。如果 P 的本地队列为空，M 会尝试从其他 P 的本地队列中 “偷取” ⼀些 G 来执⾏，这种机制称为 “⼯作窃取”，可以提⾼调度的效率。\n\n- **阻塞和唤醒**：当⼀个 Goroutine 遇到阻塞操作（如 I/O 操作、Channel 读写等）时，M 会将该 G 标记为阻塞状**阻塞和唤醒**：当⼀个 Goroutine 遇到阻塞操作（如 I/O 操作、Channel 读写等）时，M 会将该 G 标记为阻塞状态，并将其从当前 P 的队列中移除。同时，M 会继续从队列中获取其他 G 来执⾏。当阻塞操作完成后，G 会被唤醒，并重新放⼊某个 P 的队列中等待调度。\n\n- **上下⽂切换**：Goroutine 的上下⽂切换由 Go 运⾏时负责，⽽不是操作系统内核。这种⽤户态的上下⽂切换⽐内核态的上下⽂切换开销⼩得多，因此可以实现⾼效的并发调度。\n\n\n\n# Channel是什么？什么作用？底层数据结构是什么？\n\n## Channel 的作用\n\n在 Golang 并发编程中，channel（通道）是一种用于 goroutine 之间通信和同步的机制。它的主要作用包括：\n\n1. **goroutine 间通信**：channel 允许不同的 goroutine 之间传递数据，实现数据的共享和交换。\n2. **goroutine 同步**：通过 channel 可以控制 goroutine 的执行顺序，实现对并发操作的同步。\n\n## Channel 的底层原理\n\n```go\ntype hchan struct {\n\n  qcount uint // 当前缓冲区中的元素数量\n\n  dataqsiz buf uint unsafe.Pointer // 缓冲区⼤⼩（⽆缓冲区时为 0）\n\n  // 指向缓冲区的指针\n\n  elemsize uint16 // 元素⼤⼩\n\n  closed uint32 // 标记通道是否已关闭\n\n  sendx uint // 下⼀个发送操作的索引\n\n  recvx uint // 下⼀个接收操作的索引\n\n  recvq waitq // 等待接收的协程队列\n\n  sendq waitq // 等待发送的协程队列\n\n  lock mutex // 互斥锁，⽤于保护并发操作\n}\n\n\n```\n\nbuf 指向底层循环数组，只有缓冲型的 channel 才有。⽆缓冲区的通道则直接在发送和接收操作之间传递数据。\n\n sendx， recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。\n\n sendq， recvq 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据⽽被阻\n\n  塞。\n\nwaitq 是 sudog 的⼀个双向链表，⽽ sudog 实际上是对 goroutine 的⼀个封装：\n\n```go\ntype waitq struct {\n\n  first *sudog\n\n  last *sudog\n\n}\n```\n\nlock ⽤来保证每个读 channel 或写 channel 的操作都是原⼦的。\n\n- **⽆缓冲区通道**： dataqsiz 为 0，发送和接收操作必须同步完成。如果发送⽅没有接收⽅，发送⽅会阻塞，反之\n\n亦然。\n\n- **有缓冲区通道**： dataqsiz ⼤于 0，发送⽅可以将数据写⼊缓冲区，接收⽅可以从缓冲区读取数据。当缓冲区满\n\n时，发送⽅阻塞；当缓冲区为空时，接收⽅阻塞。\n\nhchan 使⽤互斥锁（ mutex）来保护对缓冲区和协程队列的访问，确保在并发操作时不会出现数据竞争。通过这些底层结构和机制， channel 实现了⾼效且安全的协程间通信。\n\n在 Golang 中，channel 可以分为无缓冲 channel 和有缓冲 channel，它们的主要区别在于通信方式和使用场景。以下是两者的通俗理解和具体区别：\n\n## 通俗理解无缓冲和有缓冲\n\n**无缓冲 channel（同步 channel）**\n\n- 无缓冲 channel 就像两个人直接进行面对面的交流。\n- 发送方和接收方必须同时准备好，才能进行数据传递。\n- 如果发送方先到，它会一直等待接收方到来；如果接收方先到，它会一直等待发送方发送数据。\n- 无缓冲 channel 的发送和接收操作是同步的，会阻塞直到双方都准备好。\n\n**有缓冲 channel（异步 channel）**\n\n- 有缓冲 channel 就像一个快递柜，发送方可以先把东西放在快递柜里，接收方可以在有空的时候来取。\n- 发送方在缓冲区有空位时可以直接把数据放进去，不需要等待接收方。\n- 接收方在缓冲区有数据时可以直接取出来，不需要等待发送方。\n- 有缓冲 channel 的发送和接收操作在缓冲区有空间或数据时可以异步进行，只有在缓冲区满或空时才会阻塞。\n\n使用场景\n\n**无缓冲 channel**\n\n- 当需要严格同步两个 goroutine 的执行顺序时。\n- 当需要确保发送方和接收方同时参与通信时。\n\n**有缓冲 channel**\n\n- 当需要解耦发送和接收操作时。\n- 当需要暂存数据，避免发送方或接收方阻塞时。\n\n\n\n# Select的用法\n\nSelect 用来处理一个 Goroutine 等待多个 Channel 的情况。类似于 Switch 语句，Select 的每个 case 都是一个通信操作（发送或接收），当有 case 满足条件的时候，则执行对应 case 块的代码。\n\n当没有 case 满足的时候，Select 逻辑块也会阻塞程序，当有多个 case 满足的时候，Select 会公平选择一个满足条件的 case 语句块执行（GO1.8 之后会随机选择一个）。为了避免阻塞，可以使用 default 。\n\n在 Golang 并发编程中，`select` 语句用于处理多个 channel 的通信。它允许程序同时监听多个 channel 上的通信操作，并根据哪个操作最先完成来执行相应的代码块。`select` 语句在处理多个并发通信时非常有用，可以实现多路复用。\n\n## 关键点\n\n1. **多路复用**：`select` 会同时监听多个 channel 上的通信操作。\n2. **随机选择**：如果有多个通信操作同时可以执行，`select` 会随机选择一个执行。\n3. **阻塞**：如果没有通信操作可以立即执行且没有默认分支，`select` 会阻塞，直到至少有一个通信操作可以执行。\n4. **默认分支**：如果有默认分支，当没有通信操作可以立即执行时，会执行默认分支的代码。\n\n## 注意事项\n\n1. **随机选择**：当多个 `case` 同时满足时，`select` 会随机选择一个执行，无法预测具体是哪一个。\n2. **阻塞**：如果没有 `default` 分支且没有通信操作可以立即执行，`select` 会阻塞。\n3. **死锁风险**：如果所有 `case` 都无法执行且没有 `default` 分支，程序可能会陷入死锁。\n4. **效率**：`select` 的效率较高，适合处理多个并发通信。\n\n\n\n\n\n# 使用sync包\n\nGolang 并发编程离不开 sync 包，里面提供了很多有用的类型和方法。常用知识点如下：\n\n## Map\n\n普通的 map 不是并发安全的，容易出现竞争问题。sync.Map 是官方提供的一个并发安全的 Map，不需要自己额外处理锁、协调等操作。该类型提供了以下方法：\n\n- Loads(): 装载键值（获取键值）\n- Store(): 储存键值\n- Delete(): 删除键值\n- LoadOrStore(): 如果存在则获取键值，不存在则存储\n- Range(): 遍历 Map\n\n\n\n## 相反，并发安全的数据有如下\n\n- sync.Map：通过读写 map来实现，读请求默认⾛读 map，如果读不到再请求写 map（加锁保证），同时在特定条件满⾜的情况下同步缓存和 DB 中的数据。misses 字段则⽤于计数，记录缓存未命中的次数，当我们要读取map 中某个 key 对应的值时，优先从 read 读取，如果 read 中不存在，则 misses 值加 1，然后继续从 dirty 中读取，当 misses 值达到某个阈值时，sync.Map 就会将 dirty 提升为 read。\n\n- sync.Pool是⼀个并发安全的临时对象池。它可以安全地被多个 goroutine 同时使⽤，⽤于缓存和复⽤临时对象，减少频繁创建和销毁对象带来的内存分配和垃圾回收压⼒，提⾼性能。\n- 原⼦类型包 sync/atomic 包;进⾏并发安全的操作。\n- 读写锁（ sync.RWMutex）包装的数据结构。\n\n- Mutex：互斥锁。对于加了锁的操作，其他的 Goroutine 在读取相应对象时会阻塞，知道互斥对象释放。频繁、大量的使用互斥锁会导致性能的降低，应该只在必须用的地方用。互斥锁使用不当还有可能造成死锁、活锁、饿死等情况，就比较复杂了。\n\n## `sync.Once`\n\n在 Golang 中，`sync.Once` 是一个用于确保某个函数或方法只被调用一次的工具。它在并发编程中非常有用，可以用来实现单例模式、资源初始化等场景，确保某些操作只执行一次，即使有多个 goroutine 同时尝试执行这些操作。\n\n### 基本用法\n\n`sync.Once` 提供了两个主要方法：\n\n1. **`Do(f func())`**：执行给定的函数 `f`，并且保证 `f` 只会被执行一次，即使有多个 goroutine 调用 `Do` 方法。\n2. **`Done() chan struct{}`**：返回一个通道，当 `Do` 方法完成时，该通道会关闭。可以用于等待 `Do` 方法的完成。\n\n示例代码\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var once sync.Once\n\n    // 定义一个需要只执行一次的函数\n    initFunc := func() {\n        fmt.Println(\"Initializing...\")\n    }\n\n    // 多个 goroutine 同时调用 once.Do\n    for i := 0; i < 5; i++ {\n        go func() {\n            once.Do(initFunc)\n        }()\n    }\n\n    // 等待所有 goroutine 完成\n    time.Sleep(100 * time.Millisecond)\n}\n```\n\n单例模式\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar (\n    instance *MySingleton\n    once     sync.Once\n)\n\ntype MySingleton struct{}\n\nfunc NewMySingleton() *MySingleton {\n    once.Do(func() {\n        instance = &MySingleton{}\n        fmt.Println(\"Singleton instance created\")\n    })\n    return instance\n}\n\nfunc main() {\n    // 多个 goroutine 同时获取单例实例\n    for i := 0; i < 5; i++ {\n        go func() {\n            singleton := NewMySingleton()\n            fmt.Println(\"Got singleton instance:\", singleton)\n        }()\n    }\n\n    // 等待所有 goroutine 完成\n    time.Sleep(100 * time.Millisecond)\n}\n```\n\n输出：\n\n```go\nSingleton instance created\nGot singleton instance: &{{}}\nGot singleton instance: &{{}}\nGot singleton instance: &{{}}\nGot singleton instance: &{{}}\nGot singleton instance: &{{}}\n```\n\n### 注意事项\n\n1. **线程安全性**：`sync.Once` 是线程安全的，可以安全地在多个 goroutine 中使用。\n2. **函数执行**：`Do` 方法中的函数只会被执行一次，即使有多个 goroutine 同时调用 `Do` 方法。\n3. **不可重置**：`sync.Once` 不能被重置，一旦执行完成，无法再次执行。\n\n`sync.Once` 是 Golang 并发编程中一个非常有用的工具，用于确保某个函数或方法只被调用一次。它在实现单例模式、资源初始化等场景中非常有用，可以简化代码并提高程序的可靠性。\n\n\n\n## 前言\n\n最近的项目都使用 Golang 进行开发，因为自己是从头自学，难免踩了很多坑。目前项目接近尾声，抽空对一些重要的知识点做一些总结。\n\n## Goroutine 与 Channel\n\n什么是 Goroutine 呢？有人说它是轻量级的进程，或者干脆说是协程。其实都不太准确，协程仅仅是在一个进程中进行子程序的切换，而 Goroutine 是可以多线程多路复用的。简而言之，Goroutine 是一个轻量级的、与其他 Goroutine 运行在同一块内存地址中的并发执行的函数模型。它的成本仅仅比堆栈的分配高一点点，所以很廉价。Goroutine 可以在多个线程上通过 Goroutine 自己的调度器实现多路复用。\n\n那什么是 Channel 呢？它是程序中一种类型化的通道，即在这个虚拟通道中传输的是某种预定义的数据类型。通过相应的操作符如 `<-` 可以在 Goroutine 之间发送和接收数据。 Channel 在默认情况下，接收或者发送的某端没有执行的时候会阻塞程序。Channel 可以在创建时定义缓冲大小，即缓冲区已满时才会发送缓存区的所有数据。\n\nChannel 最简单的用法就是利用其阻塞程序的特性来做 Goroutine 结束的标志。例如在 Goroutine 代码块外定义一个 Channel 接收其中的数据，当 Goroutine 代码块内部执行完毕时向 Channel 发送完成信号进而执行后续的代码。\n\n当程序有多个 Goroutine 或者多个 Channel ，他们管理起来就容易变得混乱。这时就可以考虑使用下文讲到的知识。\n\n## Select 的用法\n\nSelect 用来处理一个 Goroutine 等待多个 Channel 的情况。类似于 Switch 语句，Select 的每个 case 都是一个通信操作（发送或接收），当有 case 满足条件的时候，则执行对应 case 块的代码。当没有 case 满足的时候，Select 逻辑块也会阻塞程序，当有多个 case 满足的时候，Select 会公平选择一个满足条件的 case 语句块执行。为了避免阻塞，可以使用 default 。\n\n## 使用 sync 包\n\nGolang 并发编程离不开 sync 包，里面提供了很多有用的类型和方法。常用知识点如下：\n\n### Map\n\n普通的 map 不是并发安全的，容易出现竞争问题。sync.Map 是官方提供的一个并发安全的 Map，不需要自己额外处理锁、协调等操作。该类型提供了以下方法：\n\n- Loads(): 装载键值（获取键值）\n- Store(): 储存键值\n- Delete(): 删除键值\n- LoadOrStore(): 如果存在则获取键值，不存在则存储\n- Range(): 遍历 Map\n\n我在项目中使用该类型替代了自己原本定义的一个全局 Map 类型，相比自己维护互斥锁或者读写锁等操作方便了不少，而且性能有优势（具体没有测试），据官方说明该 Map 类型显著减少了锁的争用。\n\n### Mutex\n\n互斥锁。对于加了锁的操作，其他的 Goroutine 在读取相应对象时会阻塞，知道互斥对象释放。频繁、大量的使用互斥锁会导致性能的降低，应该只在必须用的地方用。互斥锁使用不当还有可能造成死锁、活锁、饿死等情况，就比较复杂了。\n\n### RWMutex\n\n读写锁。相较互斥锁，读写锁相较互斥锁性能损耗低些，因为对于只读操作只加共享锁，是支持并发的，仅在写操作上加互斥锁，明显提升了效率。\n\n### Once\n\nOnce 这个对象很有用，它是一个只执行一个操作的对象。该对象仅有一个 Do() 方法，仅当 Once 实例第一次调用 Do() 方法时，Do() 才会调用传递过来的函数。\n\n这对于要实现单例模式的代码会方便一些，定义一个 Once 对象，将要实现单例的对象的初始化方法传递给 Do()，就能保证单例的并发安全。\n\n但使用互斥锁不也能解决这个问题吗？其实不然，互斥锁的代价太高，会导致 Goroutines 无法对该变量进行并发访问。那我把它改成读写锁呢？例如：\n\n```\nvar mu sync.RWMutex // 定义读写锁\nvar someMap map[string]interface{}\n\n// 并发安全的单例\nfunc GetMap(name string) interface{} {\n    // 加读锁，并判断 someMap 是否为空\n    // 如果不为空则获取 Map 中的值\n    mu.RLock()\n    if someMap != nil {\n        foo := someMap[name]\n        mu.RUnlock()\n        return foo\n    }\n    // 注意这里无法在 else 语句将共享锁升级为互斥锁\n    mu.RUnlock()\n\n    // 如果 someMap 为空加互斥锁，并初始化 someMap\n    mu.Lock()\n\n    // 注意：必须要再一次检查是否为 nil\n    if someMap == nil { \n        CreateMap()\n    }\n    foo := someMap[name]\n    mu.Unlock()\n    return foo\n}\n```\n\n然而这种方式不觉得太复杂了吗？\n\n# Pool\n\nPool 是一组用来保存或者检索的临时对象。Pub() 方法的入参是空接口，意味着可以把任何类型的对象放置在池子中以复用，减轻垃圾回收器的压力，正确的使用能很轻松的构建高效、线程安全的自由列表。\n\n# WaitGroup\n\nWaitGroup 适用于等待多个 Goroutine 完成的逻辑下使用，控制多个 Goroutine 之间的同步。每新建一个 Goroutine 就可以调用 WaitGroup.Add() 来增加需要等待的 Goroutine 数量，当每个 Goroutine 都运行完毕时各自调用 Done() ，可以在程序的外层调用 Wait() 以阻塞程序直到所有 Goroutine 都调用了 Done()。\n\n这样就可以在程序中使每个 WaitGroup 之间是同步的，但是 WaitGroup 之内的 Goroutine 是异步的。\n\n# Context\n\n与 WaitGroup 不同，Context 实现了对串行的 Goroutine 的跟踪和控制，比如一个 Goroutine 在运行过程中派生出了其他 Goroutine，这些派生出的 Goroutine 又派生出了其他 Goroutine，这种 Goroutine 的关系链使用之前的 Channel + Select 来维护会使得程序变得异常复杂。而使用 Context 上下文来实现 Goroutine 间截止时间、取消信号或其他变量的共享和传递会变得简单。\n\nContext 有四种方法来派生出不同的上下文：\n\n- WithCancel: 传递取消信号\n- WithDeadline: 传递截止时间\n- WithTimeout: 传递超时信号\n- WithValue: 传递其他值\n\n例如 WithCancel 派生出的上下文，在对应 Goroutine 中调用 cancel() 会使所有同一上下文派生出的所有 Goroutine 关闭，在派生出的 Goroutine 中可以通过监听 ctx.Done() 来判断是否关闭 Goroutine。\n\nContext 还有许多其他的用途，在 gRPC 、gin 中大量运用了 Context。Context 是并发安全的，所以可以放心的在 Goroutines 之间传递。\n\n在Golang并发编程中，内存泄露和一些注意事项是需要特别关注的，以下是常见的情况和建议：\n\n# 常见内存泄露及注意事项\n\n1. **goroutine泄露**\n   - **场景**：goroutine因阻塞（如未关闭的channel、死循环）无法退出，导致内存泄露。每个goroutine占用2KB内存，大量goroutine泄露会造成内存占用持续增加。\n   - **原因**：goroutine在执行时被阻塞而无法退出，如未关闭的channel导致接收方一直等待。\n   - **避免**：确保goroutine有明确的退出机制，如使用`context.Context`传递取消信号，关闭channel通知协程退出。\n\n2. **time.Ticker未关闭**\n   - **场景**：time.Ticker每间隔指定时间向通道写数据，若不调用`Stop()`方法，会一直占用内存。\n   - **避免**：在使用完time.Ticker后，务必调用`Stop()`方法来停止它。\n\n3. **字符串和切片截取**\n   - **场景**：长字符串或切片被截取后，如果截取的小部分还在活跃，原大块内存将无法被回收，导致临时内存泄露。\n   - **避免**：在不需要保留原大块内存时，可以复制需要的部分到新的变量，或者使用其他方式避免共享底层数组。\n\n4. **Finalizer导致泄漏**\n   - **场景**：设置Finalizer后，对象的内存无法被垃圾回收器及时回收，尤其当存在循环引用时。\n   - **避免**：谨慎使用Finalizer，避免不必要的循环引用。\n\n5. **Deferring Function Call导致泄漏**\n   - **场景**：大量文件打开后仅在函数结束时释放，造成临时内存泄露。\n   - **避免**：在循环中打开文件时，应立即关闭，而不是等待函数结束。\n\n6. **内存分配未释放**\n   - **场景**：持续分配内存但未释放，如持续向切片中添加数据而未清理。\n   - **避免**：合理管理内存分配和释放，避免不必要的内存堆积。\n\n7. **大数组作为参数**\n   - **场景**：大数组作为形参时，值拷贝导致内存使用激增。\n   - **避免**：对于大数组，使用切片或指针传递，减少内存占用。\n\n## 注意事项\n\n1. **并发安全与同步**\n   - 共享资源需用`sync.Mutex`、`sync.RWMutex`或原子操作保护，优先使用Channel传递数据，避免直接共享内存。\n\n2. **控制并发量**\n   - 避免无限制创建协程，使用带缓冲的Channel、Worker Pool或信号量限制并发数。\n\n3. **处理协程错误**\n   - 在goroutine内部使用`defer`+`recover`处理`panic`，避免整个程序崩溃。\n\n4. **避免Channel死锁**\n   - 确保Channel的发送和接收成对出现，避免协程永久阻塞，如未关闭的Channel可能导致接收方等待。\n\n5. **利用Context传递元数据和取消信号**\n   - 使用`context.Context`传递元数据和取消信号，方便控制goroutine的生命周期。\n\n6. **合理使用锁**\n   - 避免在持有锁的情况下调用可能导致阻塞的操作，如I/O操作，防止死锁。\n\n7. **监控和分析**\n   - 使用`runtime.MemStats`监控内存使用情况，使用`pprof`进行性能分析，及时发现和解决内存和性能问题。\n\n通过遵循以上建议和注意事项，可以有效避免Golang并发编程中的内存泄露问题，编写出高效、稳定的并发程序。","slug":"Golang-并发编程实战总结","published":1,"updated":"2025-03-28T08:16:07.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm8sidd1a0000un6c6qo7a6z1","content":"<h1 id=\"Golang-并发编程实践总结\"><a href=\"#Golang-并发编程实践总结\" class=\"headerlink\" title=\"Golang 并发编程实践总结\"></a>Golang 并发编程实践总结</h1><p>目录</p>\n<ul>\n<li><a href=\"#golang-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93\">Golang 并发编程实践总结</a><ul>\n<li><a href=\"#%E6%B7%B1%E2%BC%8A%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B\">深⼊理解GMP模型</a></li>\n<li><a href=\"#Channel%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">Channel是什么</a></li>\n<li><a href=\"#Select%E7%9A%84%E7%94%A8%E6%B3%95\">Select的用法</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8sync%E5%8C%85\">使用sync包</a></li>\n<li><a href=\"#WaitGroup\">WaitGroup</a></li>\n<li><a href=\"#Pool\">Pool</a></li>\n<li><a href=\"#%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">常见内存泄露及注意事项</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"深⼊理解GMP模型\"><a href=\"#深⼊理解GMP模型\" class=\"headerlink\" title=\"深⼊理解GMP模型\"></a>深⼊理解GMP模型</h1><p><strong>【思考🤔】⾸先思考⼀个问题为什么需要协程？</strong></p>\n<p>其实答案也很明显：在多进程和多线程时代，CPU 内核负责调度，为系统提供并发处理能⼒，但也存在⼀些缺点：</p>\n<ul>\n<li><p>资源消耗⾼：进程和线程的创建、切换和销毁都会消耗⼤量 CPU 资源。</p>\n</li>\n<li><p>内存占⽤⼤：每个线程约需 4MB 内存，⼤量线程会导致内存消耗过⾼。</p>\n</li>\n<li><p>应⽤层⽆法直接控制内核调度，只能通过减少线程创建和切换来优化性能。</p>\n</li>\n</ul>\n<p>这促⽣了协程的概念：⽤户级别的轻量线程。在 Go 中，协程被称为 <code>goroutine</code>，它主要解决了内核线程的两个“太重”问题：</p>\n<ul>\n<li>创建和切换：<code>goroutine</code>  在⽤户态创建和切换，⽆需进⼊内核，开销⽐线程⼩得多。</li>\n<li>内存占⽤：<code>goroutine</code>  的初始栈只有 2KB，栈空间可动态扩展或收缩，避免了内存浪费与栈溢出⻛险。</li>\n<li>由于 <code>goroutine</code>  的轻量特性，Go 程序可以轻松创建成千上万个并发任务，⽽不⽤担⼼性能和内存问题。</li>\n</ul>\n<p><strong>【思考🤔 】第⼆个问题：</strong>golang <strong>可以在⽤户级别空间创建协程底层是靠什么实现的</strong>?</p>\n<p>其实是虽然协程在⽤户态空间运⾏，但其底层实现依赖于Go运⾏时对操作系统线程（OS Threads）的管理和调度。</p>\n<p>具体来说：Go 协程运⾏在⽤户态空间，但它们并不是直接由操作系统调度的线程。相反，<strong>Go <strong>运⾏时通过⼀个⽤户态的调度器（</strong>Scheduler</strong>）来管理协程的执⾏，并将协程映射到操作系统线程上。</p>\n<ul>\n<li>⽤户态协程（Goroutine）：轻量级的并发单元，由Go运⾏时管理。</li>\n<li>操作系统线程（OS Thread）：由操作系统调度的线程，⽤于执⾏Go运⾏时的代码。</li>\n<li>运⾏时调度器（Scheduler）：负责将协程分配到操作系统线程上执⾏。</li>\n</ul>\n<p>Go 运⾏时的调度器是协程实现的核⼼，它通过以下组件协同⼯作：</p>\n<ul>\n<li>G（goroutine）：<ul>\n<li>是⽤户态线程的抽象，可以在 M 上运⾏，存储于全局队列和 P 的本地队列（⼤⼩ 256）中。</li>\n<li><strong>特点：</strong>G是轻量级的，创建和销毁的开销极⼩。</li>\n</ul>\n</li>\n<li>M（Machine）：<ul>\n<li>是操作系统线程的抽象，⼀个 M 代表⼀个线程，最多绑定⼀个 P。M 阻塞时会释放 P，允许 P与其他空闲的 M 绑定，如果没有空闲的 M，则创建新的 M。</li>\n<li><strong>特点：</strong>M的数量通常远少于G的数量，由Go运⾏时动态管理。</li>\n</ul>\n</li>\n<li>P（Processor）：<ul>\n<li>逻辑处理器，抽象代表 CPU 核⼼。P 的数量决定了程序的并⾏能⼒，可以通过 GOMAXPROCS 设置。每个 M 需要绑定⼀个 P 进⾏任务调度。是 M 和 G 之间的桥梁。每个 P 都有⼀个本地的 Goroutine 队列，同时也可以访问全局的 Goroutine 队列。P 负责调度和管理 Goroutine 的执⾏，决定哪个 Goroutine 应该在哪个 M 上运⾏。</li>\n<li><strong>特点：</strong> P的数量通常与CPU核⼼数相匹配，⽤于充分利⽤多核CPU的计算能⼒。</li>\n</ul>\n</li>\n</ul>\n<p>Go运⾏时的调度器通过以下步骤管理协程的执⾏：</p>\n<ul>\n<li>创建协程：当调⽤go func()时，Go运⾏时会创建⼀个新的G，并将其加⼊到调度队列中。</li>\n<li>调度协程：调度器从队列中取出G，并将其分配给⼀个P。P将G绑定到⼀个M上，M开始执⾏G中的代码。</li>\n</ul>\n<p>阻塞与唤醒</p>\n<ul>\n<li>如果G在执⾏过程中阻塞（如等待I&#x2F;O操作），调度器会将该G挂起，并从队列中取出另⼀个G继续执⾏。</li>\n<li>当阻塞的G被唤醒时，调度器会将其重新加⼊到队列中，等待执⾏。</li>\n</ul>\n<p>线程复⽤：</p>\n<ul>\n<li>如果所有M都被阻塞，调度器会创建新的M来执⾏队列中的G。</li>\n<li>如果某个M完成任务，调度器会将该M回收，⽤于执⾏其他G。</li>\n</ul>\n<p>GMP 模型引⼊了 P 来解决 GM 模型的缺陷：</p>\n<ul>\n<li>⽆锁访问本地队列：P 保存 goroutine 的本地队列，M 优先从 P 的本地队列中取 G 执⾏，仅必要时访问全局队列，减少了锁竞争，提升了并发性。</li>\n<li>优化数据局部性：新创建的 G 会优先放⼊创建它的 M 绑定的 P 的本地队列中，避免频繁的数据交互，提升内存使⽤效率。</li>\n<li>Hand Off 交接机制：M 阻塞时，将绑定的 P 和其任务交给其他 M，提升了资源利⽤率和并发度。</li>\n</ul>\n<p>GMP 调度时机：介绍 GMP 的调度时机，主要分为正常调度、主动调度、被动调度和抢占调度四种情况</p>\n<p>具体调度过程</p>\n<ul>\n<li><p><strong>创建</strong> Goroutine：当使⽤ go 关键字创建⼀个新的 Goroutine 时，Go 运⾏时会为其分配⼀个 G 对象，并将其放⼊全局或某个 P 的本地 Goroutine 队列中。</p>\n</li>\n<li><p><strong>调度</strong> Goroutine <strong>到</strong> M <strong>上执⾏</strong>：M 会从 P 的本地队列或全局队列中获取⼀个 G，并将其绑定到⾃⼰身上执⾏。如果 P 的本地队列为空，M 会尝试从其他 P 的本地队列中 “偷取” ⼀些 G 来执⾏，这种机制称为 “⼯作窃取”，可以提⾼调度的效率。</p>\n</li>\n<li><p><strong>阻塞和唤醒</strong>：当⼀个 Goroutine 遇到阻塞操作（如 I&#x2F;O 操作、Channel 读写等）时，M 会将该 G 标记为阻塞状<strong>阻塞和唤醒</strong>：当⼀个 Goroutine 遇到阻塞操作（如 I&#x2F;O 操作、Channel 读写等）时，M 会将该 G 标记为阻塞状态，并将其从当前 P 的队列中移除。同时，M 会继续从队列中获取其他 G 来执⾏。当阻塞操作完成后，G 会被唤醒，并重新放⼊某个 P 的队列中等待调度。</p>\n</li>\n<li><p><strong>上下⽂切换</strong>：Goroutine 的上下⽂切换由 Go 运⾏时负责，⽽不是操作系统内核。这种⽤户态的上下⽂切换⽐内核态的上下⽂切换开销⼩得多，因此可以实现⾼效的并发调度。</p>\n</li>\n</ul>\n<h1 id=\"Channel是什么？什么作用？底层数据结构是什么？\"><a href=\"#Channel是什么？什么作用？底层数据结构是什么？\" class=\"headerlink\" title=\"Channel是什么？什么作用？底层数据结构是什么？\"></a>Channel是什么？什么作用？底层数据结构是什么？</h1><h2 id=\"Channel-的作用\"><a href=\"#Channel-的作用\" class=\"headerlink\" title=\"Channel 的作用\"></a>Channel 的作用</h2><p>在 Golang 并发编程中，channel（通道）是一种用于 goroutine 之间通信和同步的机制。它的主要作用包括：</p>\n<ol>\n<li><strong>goroutine 间通信</strong>：channel 允许不同的 goroutine 之间传递数据，实现数据的共享和交换。</li>\n<li><strong>goroutine 同步</strong>：通过 channel 可以控制 goroutine 的执行顺序，实现对并发操作的同步。</li>\n</ol>\n<h2 id=\"Channel-的底层原理\"><a href=\"#Channel-的底层原理\" class=\"headerlink\" title=\"Channel 的底层原理\"></a>Channel 的底层原理</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hchan <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  qcount <span class=\"type\">uint</span> <span class=\"comment\">// 当前缓冲区中的元素数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">  dataqsiz buf <span class=\"type\">uint</span> unsafe.Pointer <span class=\"comment\">// 缓冲区⼤⼩（⽆缓冲区时为 0）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 指向缓冲区的指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">  elemsize <span class=\"type\">uint16</span> <span class=\"comment\">// 元素⼤⼩</span></span><br><span class=\"line\"></span><br><span class=\"line\">  closed <span class=\"type\">uint32</span> <span class=\"comment\">// 标记通道是否已关闭</span></span><br><span class=\"line\"></span><br><span class=\"line\">  sendx <span class=\"type\">uint</span> <span class=\"comment\">// 下⼀个发送操作的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">  recvx <span class=\"type\">uint</span> <span class=\"comment\">// 下⼀个接收操作的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">  recvq waitq <span class=\"comment\">// 等待接收的协程队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">  sendq waitq <span class=\"comment\">// 等待发送的协程队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">  lock mutex <span class=\"comment\">// 互斥锁，⽤于保护并发操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>buf 指向底层循环数组，只有缓冲型的 channel 才有。⽆缓冲区的通道则直接在发送和接收操作之间传递数据。</p>\n<p> sendx， recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</p>\n<p> sendq， recvq 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据⽽被阻</p>\n<p>  塞。</p>\n<p>waitq 是 sudog 的⼀个双向链表，⽽ sudog 实际上是对 goroutine 的⼀个封装：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> waitq <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  first *sudog</span><br><span class=\"line\"></span><br><span class=\"line\">  last *sudog</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>lock ⽤来保证每个读 channel 或写 channel 的操作都是原⼦的。</p>\n<ul>\n<li><strong>⽆缓冲区通道</strong>： dataqsiz 为 0，发送和接收操作必须同步完成。如果发送⽅没有接收⽅，发送⽅会阻塞，反之</li>\n</ul>\n<p>亦然。</p>\n<ul>\n<li><strong>有缓冲区通道</strong>： dataqsiz ⼤于 0，发送⽅可以将数据写⼊缓冲区，接收⽅可以从缓冲区读取数据。当缓冲区满</li>\n</ul>\n<p>时，发送⽅阻塞；当缓冲区为空时，接收⽅阻塞。</p>\n<p>hchan 使⽤互斥锁（ mutex）来保护对缓冲区和协程队列的访问，确保在并发操作时不会出现数据竞争。通过这些底层结构和机制， channel 实现了⾼效且安全的协程间通信。</p>\n<p>在 Golang 中，channel 可以分为无缓冲 channel 和有缓冲 channel，它们的主要区别在于通信方式和使用场景。以下是两者的通俗理解和具体区别：</p>\n<h2 id=\"通俗理解无缓冲和有缓冲\"><a href=\"#通俗理解无缓冲和有缓冲\" class=\"headerlink\" title=\"通俗理解无缓冲和有缓冲\"></a>通俗理解无缓冲和有缓冲</h2><p><strong>无缓冲 channel（同步 channel）</strong></p>\n<ul>\n<li>无缓冲 channel 就像两个人直接进行面对面的交流。</li>\n<li>发送方和接收方必须同时准备好，才能进行数据传递。</li>\n<li>如果发送方先到，它会一直等待接收方到来；如果接收方先到，它会一直等待发送方发送数据。</li>\n<li>无缓冲 channel 的发送和接收操作是同步的，会阻塞直到双方都准备好。</li>\n</ul>\n<p><strong>有缓冲 channel（异步 channel）</strong></p>\n<ul>\n<li>有缓冲 channel 就像一个快递柜，发送方可以先把东西放在快递柜里，接收方可以在有空的时候来取。</li>\n<li>发送方在缓冲区有空位时可以直接把数据放进去，不需要等待接收方。</li>\n<li>接收方在缓冲区有数据时可以直接取出来，不需要等待发送方。</li>\n<li>有缓冲 channel 的发送和接收操作在缓冲区有空间或数据时可以异步进行，只有在缓冲区满或空时才会阻塞。</li>\n</ul>\n<p>使用场景</p>\n<p><strong>无缓冲 channel</strong></p>\n<ul>\n<li>当需要严格同步两个 goroutine 的执行顺序时。</li>\n<li>当需要确保发送方和接收方同时参与通信时。</li>\n</ul>\n<p><strong>有缓冲 channel</strong></p>\n<ul>\n<li>当需要解耦发送和接收操作时。</li>\n<li>当需要暂存数据，避免发送方或接收方阻塞时。</li>\n</ul>\n<h1 id=\"Select的用法\"><a href=\"#Select的用法\" class=\"headerlink\" title=\"Select的用法\"></a>Select的用法</h1><p>Select 用来处理一个 Goroutine 等待多个 Channel 的情况。类似于 Switch 语句，Select 的每个 case 都是一个通信操作（发送或接收），当有 case 满足条件的时候，则执行对应 case 块的代码。</p>\n<p>当没有 case 满足的时候，Select 逻辑块也会阻塞程序，当有多个 case 满足的时候，Select 会公平选择一个满足条件的 case 语句块执行（GO1.8 之后会随机选择一个）。为了避免阻塞，可以使用 default 。</p>\n<p>在 Golang 并发编程中，<code>select</code> 语句用于处理多个 channel 的通信。它允许程序同时监听多个 channel 上的通信操作，并根据哪个操作最先完成来执行相应的代码块。<code>select</code> 语句在处理多个并发通信时非常有用，可以实现多路复用。</p>\n<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><ol>\n<li><strong>多路复用</strong>：<code>select</code> 会同时监听多个 channel 上的通信操作。</li>\n<li><strong>随机选择</strong>：如果有多个通信操作同时可以执行，<code>select</code> 会随机选择一个执行。</li>\n<li><strong>阻塞</strong>：如果没有通信操作可以立即执行且没有默认分支，<code>select</code> 会阻塞，直到至少有一个通信操作可以执行。</li>\n<li><strong>默认分支</strong>：如果有默认分支，当没有通信操作可以立即执行时，会执行默认分支的代码。</li>\n</ol>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li><strong>随机选择</strong>：当多个 <code>case</code> 同时满足时，<code>select</code> 会随机选择一个执行，无法预测具体是哪一个。</li>\n<li><strong>阻塞</strong>：如果没有 <code>default</code> 分支且没有通信操作可以立即执行，<code>select</code> 会阻塞。</li>\n<li><strong>死锁风险</strong>：如果所有 <code>case</code> 都无法执行且没有 <code>default</code> 分支，程序可能会陷入死锁。</li>\n<li><strong>效率</strong>：<code>select</code> 的效率较高，适合处理多个并发通信。</li>\n</ol>\n<h1 id=\"使用sync包\"><a href=\"#使用sync包\" class=\"headerlink\" title=\"使用sync包\"></a>使用sync包</h1><p>Golang 并发编程离不开 sync 包，里面提供了很多有用的类型和方法。常用知识点如下：</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>普通的 map 不是并发安全的，容易出现竞争问题。sync.Map 是官方提供的一个并发安全的 Map，不需要自己额外处理锁、协调等操作。该类型提供了以下方法：</p>\n<ul>\n<li>Loads(): 装载键值（获取键值）</li>\n<li>Store(): 储存键值</li>\n<li>Delete(): 删除键值</li>\n<li>LoadOrStore(): 如果存在则获取键值，不存在则存储</li>\n<li>Range(): 遍历 Map</li>\n</ul>\n<h2 id=\"相反，并发安全的数据有如下\"><a href=\"#相反，并发安全的数据有如下\" class=\"headerlink\" title=\"相反，并发安全的数据有如下\"></a>相反，并发安全的数据有如下</h2><ul>\n<li><p>sync.Map：通过读写 map来实现，读请求默认⾛读 map，如果读不到再请求写 map（加锁保证），同时在特定条件满⾜的情况下同步缓存和 DB 中的数据。misses 字段则⽤于计数，记录缓存未命中的次数，当我们要读取map 中某个 key 对应的值时，优先从 read 读取，如果 read 中不存在，则 misses 值加 1，然后继续从 dirty 中读取，当 misses 值达到某个阈值时，sync.Map 就会将 dirty 提升为 read。</p>\n</li>\n<li><p>sync.Pool是⼀个并发安全的临时对象池。它可以安全地被多个 goroutine 同时使⽤，⽤于缓存和复⽤临时对象，减少频繁创建和销毁对象带来的内存分配和垃圾回收压⼒，提⾼性能。</p>\n</li>\n<li><p>原⼦类型包 sync&#x2F;atomic 包;进⾏并发安全的操作。</p>\n</li>\n<li><p>读写锁（ sync.RWMutex）包装的数据结构。</p>\n</li>\n<li><p>Mutex：互斥锁。对于加了锁的操作，其他的 Goroutine 在读取相应对象时会阻塞，知道互斥对象释放。频繁、大量的使用互斥锁会导致性能的降低，应该只在必须用的地方用。互斥锁使用不当还有可能造成死锁、活锁、饿死等情况，就比较复杂了。</p>\n</li>\n</ul>\n<h2 id=\"sync-Once\"><a href=\"#sync-Once\" class=\"headerlink\" title=\"sync.Once\"></a><code>sync.Once</code></h2><p>在 Golang 中，<code>sync.Once</code> 是一个用于确保某个函数或方法只被调用一次的工具。它在并发编程中非常有用，可以用来实现单例模式、资源初始化等场景，确保某些操作只执行一次，即使有多个 goroutine 同时尝试执行这些操作。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p><code>sync.Once</code> 提供了两个主要方法：</p>\n<ol>\n<li>**<code>Do(f func())</code>**：执行给定的函数 <code>f</code>，并且保证 <code>f</code> 只会被执行一次，即使有多个 goroutine 调用 <code>Do</code> 方法。</li>\n<li>**<code>Done() chan struct&#123;&#125;</code>**：返回一个通道，当 <code>Do</code> 方法完成时，该通道会关闭。可以用于等待 <code>Do</code> 方法的完成。</li>\n</ol>\n<p>示例代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> once sync.Once</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义一个需要只执行一次的函数</span></span><br><span class=\"line\">    initFunc := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;Initializing...&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多个 goroutine 同时调用 once.Do</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            once.Do(initFunc)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有 goroutine 完成</span></span><br><span class=\"line\">    time.Sleep(<span class=\"number\">100</span> * time.Millisecond)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单例模式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    instance *MySingleton</span><br><span class=\"line\">    once     sync.Once</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MySingleton <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewMySingleton</span><span class=\"params\">()</span></span> *MySingleton &#123;</span><br><span class=\"line\">    once.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        instance = &amp;MySingleton&#123;&#125;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;Singleton instance created&quot;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 多个 goroutine 同时获取单例实例</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            singleton := NewMySingleton()</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;Got singleton instance:&quot;</span>, singleton)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有 goroutine 完成</span></span><br><span class=\"line\">    time.Sleep(<span class=\"number\">100</span> * time.Millisecond)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Singleton instance created</span><br><span class=\"line\">Got singleton instance: &amp;&#123;&#123;&#125;&#125;</span><br><span class=\"line\">Got singleton instance: &amp;&#123;&#123;&#125;&#125;</span><br><span class=\"line\">Got singleton instance: &amp;&#123;&#123;&#125;&#125;</span><br><span class=\"line\">Got singleton instance: &amp;&#123;&#123;&#125;&#125;</span><br><span class=\"line\">Got singleton instance: &amp;&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li><strong>线程安全性</strong>：<code>sync.Once</code> 是线程安全的，可以安全地在多个 goroutine 中使用。</li>\n<li><strong>函数执行</strong>：<code>Do</code> 方法中的函数只会被执行一次，即使有多个 goroutine 同时调用 <code>Do</code> 方法。</li>\n<li><strong>不可重置</strong>：<code>sync.Once</code> 不能被重置，一旦执行完成，无法再次执行。</li>\n</ol>\n<p><code>sync.Once</code> 是 Golang 并发编程中一个非常有用的工具，用于确保某个函数或方法只被调用一次。它在实现单例模式、资源初始化等场景中非常有用，可以简化代码并提高程序的可靠性。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近的项目都使用 Golang 进行开发，因为自己是从头自学，难免踩了很多坑。目前项目接近尾声，抽空对一些重要的知识点做一些总结。</p>\n<h2 id=\"Goroutine-与-Channel\"><a href=\"#Goroutine-与-Channel\" class=\"headerlink\" title=\"Goroutine 与 Channel\"></a>Goroutine 与 Channel</h2><p>什么是 Goroutine 呢？有人说它是轻量级的进程，或者干脆说是协程。其实都不太准确，协程仅仅是在一个进程中进行子程序的切换，而 Goroutine 是可以多线程多路复用的。简而言之，Goroutine 是一个轻量级的、与其他 Goroutine 运行在同一块内存地址中的并发执行的函数模型。它的成本仅仅比堆栈的分配高一点点，所以很廉价。Goroutine 可以在多个线程上通过 Goroutine 自己的调度器实现多路复用。</p>\n<p>那什么是 Channel 呢？它是程序中一种类型化的通道，即在这个虚拟通道中传输的是某种预定义的数据类型。通过相应的操作符如 <code>&lt;-</code> 可以在 Goroutine 之间发送和接收数据。 Channel 在默认情况下，接收或者发送的某端没有执行的时候会阻塞程序。Channel 可以在创建时定义缓冲大小，即缓冲区已满时才会发送缓存区的所有数据。</p>\n<p>Channel 最简单的用法就是利用其阻塞程序的特性来做 Goroutine 结束的标志。例如在 Goroutine 代码块外定义一个 Channel 接收其中的数据，当 Goroutine 代码块内部执行完毕时向 Channel 发送完成信号进而执行后续的代码。</p>\n<p>当程序有多个 Goroutine 或者多个 Channel ，他们管理起来就容易变得混乱。这时就可以考虑使用下文讲到的知识。</p>\n<h2 id=\"Select-的用法\"><a href=\"#Select-的用法\" class=\"headerlink\" title=\"Select 的用法\"></a>Select 的用法</h2><p>Select 用来处理一个 Goroutine 等待多个 Channel 的情况。类似于 Switch 语句，Select 的每个 case 都是一个通信操作（发送或接收），当有 case 满足条件的时候，则执行对应 case 块的代码。当没有 case 满足的时候，Select 逻辑块也会阻塞程序，当有多个 case 满足的时候，Select 会公平选择一个满足条件的 case 语句块执行。为了避免阻塞，可以使用 default 。</p>\n<h2 id=\"使用-sync-包\"><a href=\"#使用-sync-包\" class=\"headerlink\" title=\"使用 sync 包\"></a>使用 sync 包</h2><p>Golang 并发编程离不开 sync 包，里面提供了很多有用的类型和方法。常用知识点如下：</p>\n<h3 id=\"Map-1\"><a href=\"#Map-1\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>普通的 map 不是并发安全的，容易出现竞争问题。sync.Map 是官方提供的一个并发安全的 Map，不需要自己额外处理锁、协调等操作。该类型提供了以下方法：</p>\n<ul>\n<li>Loads(): 装载键值（获取键值）</li>\n<li>Store(): 储存键值</li>\n<li>Delete(): 删除键值</li>\n<li>LoadOrStore(): 如果存在则获取键值，不存在则存储</li>\n<li>Range(): 遍历 Map</li>\n</ul>\n<p>我在项目中使用该类型替代了自己原本定义的一个全局 Map 类型，相比自己维护互斥锁或者读写锁等操作方便了不少，而且性能有优势（具体没有测试），据官方说明该 Map 类型显著减少了锁的争用。</p>\n<h3 id=\"Mutex\"><a href=\"#Mutex\" class=\"headerlink\" title=\"Mutex\"></a>Mutex</h3><p>互斥锁。对于加了锁的操作，其他的 Goroutine 在读取相应对象时会阻塞，知道互斥对象释放。频繁、大量的使用互斥锁会导致性能的降低，应该只在必须用的地方用。互斥锁使用不当还有可能造成死锁、活锁、饿死等情况，就比较复杂了。</p>\n<h3 id=\"RWMutex\"><a href=\"#RWMutex\" class=\"headerlink\" title=\"RWMutex\"></a>RWMutex</h3><p>读写锁。相较互斥锁，读写锁相较互斥锁性能损耗低些，因为对于只读操作只加共享锁，是支持并发的，仅在写操作上加互斥锁，明显提升了效率。</p>\n<h3 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h3><p>Once 这个对象很有用，它是一个只执行一个操作的对象。该对象仅有一个 Do() 方法，仅当 Once 实例第一次调用 Do() 方法时，Do() 才会调用传递过来的函数。</p>\n<p>这对于要实现单例模式的代码会方便一些，定义一个 Once 对象，将要实现单例的对象的初始化方法传递给 Do()，就能保证单例的并发安全。</p>\n<p>但使用互斥锁不也能解决这个问题吗？其实不然，互斥锁的代价太高，会导致 Goroutines 无法对该变量进行并发访问。那我把它改成读写锁呢？例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mu sync.RWMutex // 定义读写锁</span><br><span class=\"line\">var someMap map[string]interface&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 并发安全的单例</span><br><span class=\"line\">func GetMap(name string) interface&#123;&#125; &#123;</span><br><span class=\"line\">    // 加读锁，并判断 someMap 是否为空</span><br><span class=\"line\">    // 如果不为空则获取 Map 中的值</span><br><span class=\"line\">    mu.RLock()</span><br><span class=\"line\">    if someMap != nil &#123;</span><br><span class=\"line\">        foo := someMap[name]</span><br><span class=\"line\">        mu.RUnlock()</span><br><span class=\"line\">        return foo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 注意这里无法在 else 语句将共享锁升级为互斥锁</span><br><span class=\"line\">    mu.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果 someMap 为空加互斥锁，并初始化 someMap</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    // 注意：必须要再一次检查是否为 nil</span><br><span class=\"line\">    if someMap == nil &#123; </span><br><span class=\"line\">        CreateMap()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    foo := someMap[name]</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">    return foo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然而这种方式不觉得太复杂了吗？</p>\n<h1 id=\"Pool\"><a href=\"#Pool\" class=\"headerlink\" title=\"Pool\"></a>Pool</h1><p>Pool 是一组用来保存或者检索的临时对象。Pub() 方法的入参是空接口，意味着可以把任何类型的对象放置在池子中以复用，减轻垃圾回收器的压力，正确的使用能很轻松的构建高效、线程安全的自由列表。</p>\n<h1 id=\"WaitGroup\"><a href=\"#WaitGroup\" class=\"headerlink\" title=\"WaitGroup\"></a>WaitGroup</h1><p>WaitGroup 适用于等待多个 Goroutine 完成的逻辑下使用，控制多个 Goroutine 之间的同步。每新建一个 Goroutine 就可以调用 WaitGroup.Add() 来增加需要等待的 Goroutine 数量，当每个 Goroutine 都运行完毕时各自调用 Done() ，可以在程序的外层调用 Wait() 以阻塞程序直到所有 Goroutine 都调用了 Done()。</p>\n<p>这样就可以在程序中使每个 WaitGroup 之间是同步的，但是 WaitGroup 之内的 Goroutine 是异步的。</p>\n<h1 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h1><p>与 WaitGroup 不同，Context 实现了对串行的 Goroutine 的跟踪和控制，比如一个 Goroutine 在运行过程中派生出了其他 Goroutine，这些派生出的 Goroutine 又派生出了其他 Goroutine，这种 Goroutine 的关系链使用之前的 Channel + Select 来维护会使得程序变得异常复杂。而使用 Context 上下文来实现 Goroutine 间截止时间、取消信号或其他变量的共享和传递会变得简单。</p>\n<p>Context 有四种方法来派生出不同的上下文：</p>\n<ul>\n<li>WithCancel: 传递取消信号</li>\n<li>WithDeadline: 传递截止时间</li>\n<li>WithTimeout: 传递超时信号</li>\n<li>WithValue: 传递其他值</li>\n</ul>\n<p>例如 WithCancel 派生出的上下文，在对应 Goroutine 中调用 cancel() 会使所有同一上下文派生出的所有 Goroutine 关闭，在派生出的 Goroutine 中可以通过监听 ctx.Done() 来判断是否关闭 Goroutine。</p>\n<p>Context 还有许多其他的用途，在 gRPC 、gin 中大量运用了 Context。Context 是并发安全的，所以可以放心的在 Goroutines 之间传递。</p>\n<p>在Golang并发编程中，内存泄露和一些注意事项是需要特别关注的，以下是常见的情况和建议：</p>\n<h1 id=\"常见内存泄露及注意事项\"><a href=\"#常见内存泄露及注意事项\" class=\"headerlink\" title=\"常见内存泄露及注意事项\"></a>常见内存泄露及注意事项</h1><ol>\n<li><p><strong>goroutine泄露</strong></p>\n<ul>\n<li><strong>场景</strong>：goroutine因阻塞（如未关闭的channel、死循环）无法退出，导致内存泄露。每个goroutine占用2KB内存，大量goroutine泄露会造成内存占用持续增加。</li>\n<li><strong>原因</strong>：goroutine在执行时被阻塞而无法退出，如未关闭的channel导致接收方一直等待。</li>\n<li><strong>避免</strong>：确保goroutine有明确的退出机制，如使用<code>context.Context</code>传递取消信号，关闭channel通知协程退出。</li>\n</ul>\n</li>\n<li><p><strong>time.Ticker未关闭</strong></p>\n<ul>\n<li><strong>场景</strong>：time.Ticker每间隔指定时间向通道写数据，若不调用<code>Stop()</code>方法，会一直占用内存。</li>\n<li><strong>避免</strong>：在使用完time.Ticker后，务必调用<code>Stop()</code>方法来停止它。</li>\n</ul>\n</li>\n<li><p><strong>字符串和切片截取</strong></p>\n<ul>\n<li><strong>场景</strong>：长字符串或切片被截取后，如果截取的小部分还在活跃，原大块内存将无法被回收，导致临时内存泄露。</li>\n<li><strong>避免</strong>：在不需要保留原大块内存时，可以复制需要的部分到新的变量，或者使用其他方式避免共享底层数组。</li>\n</ul>\n</li>\n<li><p><strong>Finalizer导致泄漏</strong></p>\n<ul>\n<li><strong>场景</strong>：设置Finalizer后，对象的内存无法被垃圾回收器及时回收，尤其当存在循环引用时。</li>\n<li><strong>避免</strong>：谨慎使用Finalizer，避免不必要的循环引用。</li>\n</ul>\n</li>\n<li><p><strong>Deferring Function Call导致泄漏</strong></p>\n<ul>\n<li><strong>场景</strong>：大量文件打开后仅在函数结束时释放，造成临时内存泄露。</li>\n<li><strong>避免</strong>：在循环中打开文件时，应立即关闭，而不是等待函数结束。</li>\n</ul>\n</li>\n<li><p><strong>内存分配未释放</strong></p>\n<ul>\n<li><strong>场景</strong>：持续分配内存但未释放，如持续向切片中添加数据而未清理。</li>\n<li><strong>避免</strong>：合理管理内存分配和释放，避免不必要的内存堆积。</li>\n</ul>\n</li>\n<li><p><strong>大数组作为参数</strong></p>\n<ul>\n<li><strong>场景</strong>：大数组作为形参时，值拷贝导致内存使用激增。</li>\n<li><strong>避免</strong>：对于大数组，使用切片或指针传递，减少内存占用。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"注意事项-2\"><a href=\"#注意事项-2\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li><p><strong>并发安全与同步</strong></p>\n<ul>\n<li>共享资源需用<code>sync.Mutex</code>、<code>sync.RWMutex</code>或原子操作保护，优先使用Channel传递数据，避免直接共享内存。</li>\n</ul>\n</li>\n<li><p><strong>控制并发量</strong></p>\n<ul>\n<li>避免无限制创建协程，使用带缓冲的Channel、Worker Pool或信号量限制并发数。</li>\n</ul>\n</li>\n<li><p><strong>处理协程错误</strong></p>\n<ul>\n<li>在goroutine内部使用<code>defer</code>+<code>recover</code>处理<code>panic</code>，避免整个程序崩溃。</li>\n</ul>\n</li>\n<li><p><strong>避免Channel死锁</strong></p>\n<ul>\n<li>确保Channel的发送和接收成对出现，避免协程永久阻塞，如未关闭的Channel可能导致接收方等待。</li>\n</ul>\n</li>\n<li><p><strong>利用Context传递元数据和取消信号</strong></p>\n<ul>\n<li>使用<code>context.Context</code>传递元数据和取消信号，方便控制goroutine的生命周期。</li>\n</ul>\n</li>\n<li><p><strong>合理使用锁</strong></p>\n<ul>\n<li>避免在持有锁的情况下调用可能导致阻塞的操作，如I&#x2F;O操作，防止死锁。</li>\n</ul>\n</li>\n<li><p><strong>监控和分析</strong></p>\n<ul>\n<li>使用<code>runtime.MemStats</code>监控内存使用情况，使用<code>pprof</code>进行性能分析，及时发现和解决内存和性能问题。</li>\n</ul>\n</li>\n</ol>\n<p>通过遵循以上建议和注意事项，可以有效避免Golang并发编程中的内存泄露问题，编写出高效、稳定的并发程序。</p>\n","site":{"data":{"languages":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}},"excerpt":"","more":"<h1 id=\"Golang-并发编程实践总结\"><a href=\"#Golang-并发编程实践总结\" class=\"headerlink\" title=\"Golang 并发编程实践总结\"></a>Golang 并发编程实践总结</h1><p>目录</p>\n<ul>\n<li><a href=\"#golang-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93\">Golang 并发编程实践总结</a><ul>\n<li><a href=\"#%E6%B7%B1%E2%BC%8A%E7%90%86%E8%A7%A3GMP%E6%A8%A1%E5%9E%8B\">深⼊理解GMP模型</a></li>\n<li><a href=\"#Channel%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">Channel是什么</a></li>\n<li><a href=\"#Select%E7%9A%84%E7%94%A8%E6%B3%95\">Select的用法</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8sync%E5%8C%85\">使用sync包</a></li>\n<li><a href=\"#WaitGroup\">WaitGroup</a></li>\n<li><a href=\"#Pool\">Pool</a></li>\n<li><a href=\"#%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">常见内存泄露及注意事项</a></li>\n</ul>\n</li>\n</ul>\n<h1 id=\"深⼊理解GMP模型\"><a href=\"#深⼊理解GMP模型\" class=\"headerlink\" title=\"深⼊理解GMP模型\"></a>深⼊理解GMP模型</h1><p><strong>【思考🤔】⾸先思考⼀个问题为什么需要协程？</strong></p>\n<p>其实答案也很明显：在多进程和多线程时代，CPU 内核负责调度，为系统提供并发处理能⼒，但也存在⼀些缺点：</p>\n<ul>\n<li><p>资源消耗⾼：进程和线程的创建、切换和销毁都会消耗⼤量 CPU 资源。</p>\n</li>\n<li><p>内存占⽤⼤：每个线程约需 4MB 内存，⼤量线程会导致内存消耗过⾼。</p>\n</li>\n<li><p>应⽤层⽆法直接控制内核调度，只能通过减少线程创建和切换来优化性能。</p>\n</li>\n</ul>\n<p>这促⽣了协程的概念：⽤户级别的轻量线程。在 Go 中，协程被称为 <code>goroutine</code>，它主要解决了内核线程的两个“太重”问题：</p>\n<ul>\n<li>创建和切换：<code>goroutine</code>  在⽤户态创建和切换，⽆需进⼊内核，开销⽐线程⼩得多。</li>\n<li>内存占⽤：<code>goroutine</code>  的初始栈只有 2KB，栈空间可动态扩展或收缩，避免了内存浪费与栈溢出⻛险。</li>\n<li>由于 <code>goroutine</code>  的轻量特性，Go 程序可以轻松创建成千上万个并发任务，⽽不⽤担⼼性能和内存问题。</li>\n</ul>\n<p><strong>【思考🤔 】第⼆个问题：</strong>golang <strong>可以在⽤户级别空间创建协程底层是靠什么实现的</strong>?</p>\n<p>其实是虽然协程在⽤户态空间运⾏，但其底层实现依赖于Go运⾏时对操作系统线程（OS Threads）的管理和调度。</p>\n<p>具体来说：Go 协程运⾏在⽤户态空间，但它们并不是直接由操作系统调度的线程。相反，<strong>Go <strong>运⾏时通过⼀个⽤户态的调度器（</strong>Scheduler</strong>）来管理协程的执⾏，并将协程映射到操作系统线程上。</p>\n<ul>\n<li>⽤户态协程（Goroutine）：轻量级的并发单元，由Go运⾏时管理。</li>\n<li>操作系统线程（OS Thread）：由操作系统调度的线程，⽤于执⾏Go运⾏时的代码。</li>\n<li>运⾏时调度器（Scheduler）：负责将协程分配到操作系统线程上执⾏。</li>\n</ul>\n<p>Go 运⾏时的调度器是协程实现的核⼼，它通过以下组件协同⼯作：</p>\n<ul>\n<li>G（goroutine）：<ul>\n<li>是⽤户态线程的抽象，可以在 M 上运⾏，存储于全局队列和 P 的本地队列（⼤⼩ 256）中。</li>\n<li><strong>特点：</strong>G是轻量级的，创建和销毁的开销极⼩。</li>\n</ul>\n</li>\n<li>M（Machine）：<ul>\n<li>是操作系统线程的抽象，⼀个 M 代表⼀个线程，最多绑定⼀个 P。M 阻塞时会释放 P，允许 P与其他空闲的 M 绑定，如果没有空闲的 M，则创建新的 M。</li>\n<li><strong>特点：</strong>M的数量通常远少于G的数量，由Go运⾏时动态管理。</li>\n</ul>\n</li>\n<li>P（Processor）：<ul>\n<li>逻辑处理器，抽象代表 CPU 核⼼。P 的数量决定了程序的并⾏能⼒，可以通过 GOMAXPROCS 设置。每个 M 需要绑定⼀个 P 进⾏任务调度。是 M 和 G 之间的桥梁。每个 P 都有⼀个本地的 Goroutine 队列，同时也可以访问全局的 Goroutine 队列。P 负责调度和管理 Goroutine 的执⾏，决定哪个 Goroutine 应该在哪个 M 上运⾏。</li>\n<li><strong>特点：</strong> P的数量通常与CPU核⼼数相匹配，⽤于充分利⽤多核CPU的计算能⼒。</li>\n</ul>\n</li>\n</ul>\n<p>Go运⾏时的调度器通过以下步骤管理协程的执⾏：</p>\n<ul>\n<li>创建协程：当调⽤go func()时，Go运⾏时会创建⼀个新的G，并将其加⼊到调度队列中。</li>\n<li>调度协程：调度器从队列中取出G，并将其分配给⼀个P。P将G绑定到⼀个M上，M开始执⾏G中的代码。</li>\n</ul>\n<p>阻塞与唤醒</p>\n<ul>\n<li>如果G在执⾏过程中阻塞（如等待I&#x2F;O操作），调度器会将该G挂起，并从队列中取出另⼀个G继续执⾏。</li>\n<li>当阻塞的G被唤醒时，调度器会将其重新加⼊到队列中，等待执⾏。</li>\n</ul>\n<p>线程复⽤：</p>\n<ul>\n<li>如果所有M都被阻塞，调度器会创建新的M来执⾏队列中的G。</li>\n<li>如果某个M完成任务，调度器会将该M回收，⽤于执⾏其他G。</li>\n</ul>\n<p>GMP 模型引⼊了 P 来解决 GM 模型的缺陷：</p>\n<ul>\n<li>⽆锁访问本地队列：P 保存 goroutine 的本地队列，M 优先从 P 的本地队列中取 G 执⾏，仅必要时访问全局队列，减少了锁竞争，提升了并发性。</li>\n<li>优化数据局部性：新创建的 G 会优先放⼊创建它的 M 绑定的 P 的本地队列中，避免频繁的数据交互，提升内存使⽤效率。</li>\n<li>Hand Off 交接机制：M 阻塞时，将绑定的 P 和其任务交给其他 M，提升了资源利⽤率和并发度。</li>\n</ul>\n<p>GMP 调度时机：介绍 GMP 的调度时机，主要分为正常调度、主动调度、被动调度和抢占调度四种情况</p>\n<p>具体调度过程</p>\n<ul>\n<li><p><strong>创建</strong> Goroutine：当使⽤ go 关键字创建⼀个新的 Goroutine 时，Go 运⾏时会为其分配⼀个 G 对象，并将其放⼊全局或某个 P 的本地 Goroutine 队列中。</p>\n</li>\n<li><p><strong>调度</strong> Goroutine <strong>到</strong> M <strong>上执⾏</strong>：M 会从 P 的本地队列或全局队列中获取⼀个 G，并将其绑定到⾃⼰身上执⾏。如果 P 的本地队列为空，M 会尝试从其他 P 的本地队列中 “偷取” ⼀些 G 来执⾏，这种机制称为 “⼯作窃取”，可以提⾼调度的效率。</p>\n</li>\n<li><p><strong>阻塞和唤醒</strong>：当⼀个 Goroutine 遇到阻塞操作（如 I&#x2F;O 操作、Channel 读写等）时，M 会将该 G 标记为阻塞状<strong>阻塞和唤醒</strong>：当⼀个 Goroutine 遇到阻塞操作（如 I&#x2F;O 操作、Channel 读写等）时，M 会将该 G 标记为阻塞状态，并将其从当前 P 的队列中移除。同时，M 会继续从队列中获取其他 G 来执⾏。当阻塞操作完成后，G 会被唤醒，并重新放⼊某个 P 的队列中等待调度。</p>\n</li>\n<li><p><strong>上下⽂切换</strong>：Goroutine 的上下⽂切换由 Go 运⾏时负责，⽽不是操作系统内核。这种⽤户态的上下⽂切换⽐内核态的上下⽂切换开销⼩得多，因此可以实现⾼效的并发调度。</p>\n</li>\n</ul>\n<h1 id=\"Channel是什么？什么作用？底层数据结构是什么？\"><a href=\"#Channel是什么？什么作用？底层数据结构是什么？\" class=\"headerlink\" title=\"Channel是什么？什么作用？底层数据结构是什么？\"></a>Channel是什么？什么作用？底层数据结构是什么？</h1><h2 id=\"Channel-的作用\"><a href=\"#Channel-的作用\" class=\"headerlink\" title=\"Channel 的作用\"></a>Channel 的作用</h2><p>在 Golang 并发编程中，channel（通道）是一种用于 goroutine 之间通信和同步的机制。它的主要作用包括：</p>\n<ol>\n<li><strong>goroutine 间通信</strong>：channel 允许不同的 goroutine 之间传递数据，实现数据的共享和交换。</li>\n<li><strong>goroutine 同步</strong>：通过 channel 可以控制 goroutine 的执行顺序，实现对并发操作的同步。</li>\n</ol>\n<h2 id=\"Channel-的底层原理\"><a href=\"#Channel-的底层原理\" class=\"headerlink\" title=\"Channel 的底层原理\"></a>Channel 的底层原理</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hchan <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  qcount <span class=\"type\">uint</span> <span class=\"comment\">// 当前缓冲区中的元素数量</span></span><br><span class=\"line\"></span><br><span class=\"line\">  dataqsiz buf <span class=\"type\">uint</span> unsafe.Pointer <span class=\"comment\">// 缓冲区⼤⼩（⽆缓冲区时为 0）</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 指向缓冲区的指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">  elemsize <span class=\"type\">uint16</span> <span class=\"comment\">// 元素⼤⼩</span></span><br><span class=\"line\"></span><br><span class=\"line\">  closed <span class=\"type\">uint32</span> <span class=\"comment\">// 标记通道是否已关闭</span></span><br><span class=\"line\"></span><br><span class=\"line\">  sendx <span class=\"type\">uint</span> <span class=\"comment\">// 下⼀个发送操作的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">  recvx <span class=\"type\">uint</span> <span class=\"comment\">// 下⼀个接收操作的索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">  recvq waitq <span class=\"comment\">// 等待接收的协程队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">  sendq waitq <span class=\"comment\">// 等待发送的协程队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">  lock mutex <span class=\"comment\">// 互斥锁，⽤于保护并发操作</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>buf 指向底层循环数组，只有缓冲型的 channel 才有。⽆缓冲区的通道则直接在发送和接收操作之间传递数据。</p>\n<p> sendx， recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</p>\n<p> sendq， recvq 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据⽽被阻</p>\n<p>  塞。</p>\n<p>waitq 是 sudog 的⼀个双向链表，⽽ sudog 实际上是对 goroutine 的⼀个封装：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> waitq <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  first *sudog</span><br><span class=\"line\"></span><br><span class=\"line\">  last *sudog</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>lock ⽤来保证每个读 channel 或写 channel 的操作都是原⼦的。</p>\n<ul>\n<li><strong>⽆缓冲区通道</strong>： dataqsiz 为 0，发送和接收操作必须同步完成。如果发送⽅没有接收⽅，发送⽅会阻塞，反之</li>\n</ul>\n<p>亦然。</p>\n<ul>\n<li><strong>有缓冲区通道</strong>： dataqsiz ⼤于 0，发送⽅可以将数据写⼊缓冲区，接收⽅可以从缓冲区读取数据。当缓冲区满</li>\n</ul>\n<p>时，发送⽅阻塞；当缓冲区为空时，接收⽅阻塞。</p>\n<p>hchan 使⽤互斥锁（ mutex）来保护对缓冲区和协程队列的访问，确保在并发操作时不会出现数据竞争。通过这些底层结构和机制， channel 实现了⾼效且安全的协程间通信。</p>\n<p>在 Golang 中，channel 可以分为无缓冲 channel 和有缓冲 channel，它们的主要区别在于通信方式和使用场景。以下是两者的通俗理解和具体区别：</p>\n<h2 id=\"通俗理解无缓冲和有缓冲\"><a href=\"#通俗理解无缓冲和有缓冲\" class=\"headerlink\" title=\"通俗理解无缓冲和有缓冲\"></a>通俗理解无缓冲和有缓冲</h2><p><strong>无缓冲 channel（同步 channel）</strong></p>\n<ul>\n<li>无缓冲 channel 就像两个人直接进行面对面的交流。</li>\n<li>发送方和接收方必须同时准备好，才能进行数据传递。</li>\n<li>如果发送方先到，它会一直等待接收方到来；如果接收方先到，它会一直等待发送方发送数据。</li>\n<li>无缓冲 channel 的发送和接收操作是同步的，会阻塞直到双方都准备好。</li>\n</ul>\n<p><strong>有缓冲 channel（异步 channel）</strong></p>\n<ul>\n<li>有缓冲 channel 就像一个快递柜，发送方可以先把东西放在快递柜里，接收方可以在有空的时候来取。</li>\n<li>发送方在缓冲区有空位时可以直接把数据放进去，不需要等待接收方。</li>\n<li>接收方在缓冲区有数据时可以直接取出来，不需要等待发送方。</li>\n<li>有缓冲 channel 的发送和接收操作在缓冲区有空间或数据时可以异步进行，只有在缓冲区满或空时才会阻塞。</li>\n</ul>\n<p>使用场景</p>\n<p><strong>无缓冲 channel</strong></p>\n<ul>\n<li>当需要严格同步两个 goroutine 的执行顺序时。</li>\n<li>当需要确保发送方和接收方同时参与通信时。</li>\n</ul>\n<p><strong>有缓冲 channel</strong></p>\n<ul>\n<li>当需要解耦发送和接收操作时。</li>\n<li>当需要暂存数据，避免发送方或接收方阻塞时。</li>\n</ul>\n<h1 id=\"Select的用法\"><a href=\"#Select的用法\" class=\"headerlink\" title=\"Select的用法\"></a>Select的用法</h1><p>Select 用来处理一个 Goroutine 等待多个 Channel 的情况。类似于 Switch 语句，Select 的每个 case 都是一个通信操作（发送或接收），当有 case 满足条件的时候，则执行对应 case 块的代码。</p>\n<p>当没有 case 满足的时候，Select 逻辑块也会阻塞程序，当有多个 case 满足的时候，Select 会公平选择一个满足条件的 case 语句块执行（GO1.8 之后会随机选择一个）。为了避免阻塞，可以使用 default 。</p>\n<p>在 Golang 并发编程中，<code>select</code> 语句用于处理多个 channel 的通信。它允许程序同时监听多个 channel 上的通信操作，并根据哪个操作最先完成来执行相应的代码块。<code>select</code> 语句在处理多个并发通信时非常有用，可以实现多路复用。</p>\n<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><ol>\n<li><strong>多路复用</strong>：<code>select</code> 会同时监听多个 channel 上的通信操作。</li>\n<li><strong>随机选择</strong>：如果有多个通信操作同时可以执行，<code>select</code> 会随机选择一个执行。</li>\n<li><strong>阻塞</strong>：如果没有通信操作可以立即执行且没有默认分支，<code>select</code> 会阻塞，直到至少有一个通信操作可以执行。</li>\n<li><strong>默认分支</strong>：如果有默认分支，当没有通信操作可以立即执行时，会执行默认分支的代码。</li>\n</ol>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li><strong>随机选择</strong>：当多个 <code>case</code> 同时满足时，<code>select</code> 会随机选择一个执行，无法预测具体是哪一个。</li>\n<li><strong>阻塞</strong>：如果没有 <code>default</code> 分支且没有通信操作可以立即执行，<code>select</code> 会阻塞。</li>\n<li><strong>死锁风险</strong>：如果所有 <code>case</code> 都无法执行且没有 <code>default</code> 分支，程序可能会陷入死锁。</li>\n<li><strong>效率</strong>：<code>select</code> 的效率较高，适合处理多个并发通信。</li>\n</ol>\n<h1 id=\"使用sync包\"><a href=\"#使用sync包\" class=\"headerlink\" title=\"使用sync包\"></a>使用sync包</h1><p>Golang 并发编程离不开 sync 包，里面提供了很多有用的类型和方法。常用知识点如下：</p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>普通的 map 不是并发安全的，容易出现竞争问题。sync.Map 是官方提供的一个并发安全的 Map，不需要自己额外处理锁、协调等操作。该类型提供了以下方法：</p>\n<ul>\n<li>Loads(): 装载键值（获取键值）</li>\n<li>Store(): 储存键值</li>\n<li>Delete(): 删除键值</li>\n<li>LoadOrStore(): 如果存在则获取键值，不存在则存储</li>\n<li>Range(): 遍历 Map</li>\n</ul>\n<h2 id=\"相反，并发安全的数据有如下\"><a href=\"#相反，并发安全的数据有如下\" class=\"headerlink\" title=\"相反，并发安全的数据有如下\"></a>相反，并发安全的数据有如下</h2><ul>\n<li><p>sync.Map：通过读写 map来实现，读请求默认⾛读 map，如果读不到再请求写 map（加锁保证），同时在特定条件满⾜的情况下同步缓存和 DB 中的数据。misses 字段则⽤于计数，记录缓存未命中的次数，当我们要读取map 中某个 key 对应的值时，优先从 read 读取，如果 read 中不存在，则 misses 值加 1，然后继续从 dirty 中读取，当 misses 值达到某个阈值时，sync.Map 就会将 dirty 提升为 read。</p>\n</li>\n<li><p>sync.Pool是⼀个并发安全的临时对象池。它可以安全地被多个 goroutine 同时使⽤，⽤于缓存和复⽤临时对象，减少频繁创建和销毁对象带来的内存分配和垃圾回收压⼒，提⾼性能。</p>\n</li>\n<li><p>原⼦类型包 sync&#x2F;atomic 包;进⾏并发安全的操作。</p>\n</li>\n<li><p>读写锁（ sync.RWMutex）包装的数据结构。</p>\n</li>\n<li><p>Mutex：互斥锁。对于加了锁的操作，其他的 Goroutine 在读取相应对象时会阻塞，知道互斥对象释放。频繁、大量的使用互斥锁会导致性能的降低，应该只在必须用的地方用。互斥锁使用不当还有可能造成死锁、活锁、饿死等情况，就比较复杂了。</p>\n</li>\n</ul>\n<h2 id=\"sync-Once\"><a href=\"#sync-Once\" class=\"headerlink\" title=\"sync.Once\"></a><code>sync.Once</code></h2><p>在 Golang 中，<code>sync.Once</code> 是一个用于确保某个函数或方法只被调用一次的工具。它在并发编程中非常有用，可以用来实现单例模式、资源初始化等场景，确保某些操作只执行一次，即使有多个 goroutine 同时尝试执行这些操作。</p>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p><code>sync.Once</code> 提供了两个主要方法：</p>\n<ol>\n<li>**<code>Do(f func())</code>**：执行给定的函数 <code>f</code>，并且保证 <code>f</code> 只会被执行一次，即使有多个 goroutine 调用 <code>Do</code> 方法。</li>\n<li>**<code>Done() chan struct&#123;&#125;</code>**：返回一个通道，当 <code>Do</code> 方法完成时，该通道会关闭。可以用于等待 <code>Do</code> 方法的完成。</li>\n</ol>\n<p>示例代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> once sync.Once</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义一个需要只执行一次的函数</span></span><br><span class=\"line\">    initFunc := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;Initializing...&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 多个 goroutine 同时调用 once.Do</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            once.Do(initFunc)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有 goroutine 完成</span></span><br><span class=\"line\">    time.Sleep(<span class=\"number\">100</span> * time.Millisecond)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单例模式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    instance *MySingleton</span><br><span class=\"line\">    once     sync.Once</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MySingleton <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewMySingleton</span><span class=\"params\">()</span></span> *MySingleton &#123;</span><br><span class=\"line\">    once.Do(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        instance = &amp;MySingleton&#123;&#125;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;Singleton instance created&quot;</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 多个 goroutine 同时获取单例实例</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            singleton := NewMySingleton()</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;Got singleton instance:&quot;</span>, singleton)</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待所有 goroutine 完成</span></span><br><span class=\"line\">    time.Sleep(<span class=\"number\">100</span> * time.Millisecond)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Singleton instance created</span><br><span class=\"line\">Got singleton instance: &amp;&#123;&#123;&#125;&#125;</span><br><span class=\"line\">Got singleton instance: &amp;&#123;&#123;&#125;&#125;</span><br><span class=\"line\">Got singleton instance: &amp;&#123;&#123;&#125;&#125;</span><br><span class=\"line\">Got singleton instance: &amp;&#123;&#123;&#125;&#125;</span><br><span class=\"line\">Got singleton instance: &amp;&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ol>\n<li><strong>线程安全性</strong>：<code>sync.Once</code> 是线程安全的，可以安全地在多个 goroutine 中使用。</li>\n<li><strong>函数执行</strong>：<code>Do</code> 方法中的函数只会被执行一次，即使有多个 goroutine 同时调用 <code>Do</code> 方法。</li>\n<li><strong>不可重置</strong>：<code>sync.Once</code> 不能被重置，一旦执行完成，无法再次执行。</li>\n</ol>\n<p><code>sync.Once</code> 是 Golang 并发编程中一个非常有用的工具，用于确保某个函数或方法只被调用一次。它在实现单例模式、资源初始化等场景中非常有用，可以简化代码并提高程序的可靠性。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近的项目都使用 Golang 进行开发，因为自己是从头自学，难免踩了很多坑。目前项目接近尾声，抽空对一些重要的知识点做一些总结。</p>\n<h2 id=\"Goroutine-与-Channel\"><a href=\"#Goroutine-与-Channel\" class=\"headerlink\" title=\"Goroutine 与 Channel\"></a>Goroutine 与 Channel</h2><p>什么是 Goroutine 呢？有人说它是轻量级的进程，或者干脆说是协程。其实都不太准确，协程仅仅是在一个进程中进行子程序的切换，而 Goroutine 是可以多线程多路复用的。简而言之，Goroutine 是一个轻量级的、与其他 Goroutine 运行在同一块内存地址中的并发执行的函数模型。它的成本仅仅比堆栈的分配高一点点，所以很廉价。Goroutine 可以在多个线程上通过 Goroutine 自己的调度器实现多路复用。</p>\n<p>那什么是 Channel 呢？它是程序中一种类型化的通道，即在这个虚拟通道中传输的是某种预定义的数据类型。通过相应的操作符如 <code>&lt;-</code> 可以在 Goroutine 之间发送和接收数据。 Channel 在默认情况下，接收或者发送的某端没有执行的时候会阻塞程序。Channel 可以在创建时定义缓冲大小，即缓冲区已满时才会发送缓存区的所有数据。</p>\n<p>Channel 最简单的用法就是利用其阻塞程序的特性来做 Goroutine 结束的标志。例如在 Goroutine 代码块外定义一个 Channel 接收其中的数据，当 Goroutine 代码块内部执行完毕时向 Channel 发送完成信号进而执行后续的代码。</p>\n<p>当程序有多个 Goroutine 或者多个 Channel ，他们管理起来就容易变得混乱。这时就可以考虑使用下文讲到的知识。</p>\n<h2 id=\"Select-的用法\"><a href=\"#Select-的用法\" class=\"headerlink\" title=\"Select 的用法\"></a>Select 的用法</h2><p>Select 用来处理一个 Goroutine 等待多个 Channel 的情况。类似于 Switch 语句，Select 的每个 case 都是一个通信操作（发送或接收），当有 case 满足条件的时候，则执行对应 case 块的代码。当没有 case 满足的时候，Select 逻辑块也会阻塞程序，当有多个 case 满足的时候，Select 会公平选择一个满足条件的 case 语句块执行。为了避免阻塞，可以使用 default 。</p>\n<h2 id=\"使用-sync-包\"><a href=\"#使用-sync-包\" class=\"headerlink\" title=\"使用 sync 包\"></a>使用 sync 包</h2><p>Golang 并发编程离不开 sync 包，里面提供了很多有用的类型和方法。常用知识点如下：</p>\n<h3 id=\"Map-1\"><a href=\"#Map-1\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>普通的 map 不是并发安全的，容易出现竞争问题。sync.Map 是官方提供的一个并发安全的 Map，不需要自己额外处理锁、协调等操作。该类型提供了以下方法：</p>\n<ul>\n<li>Loads(): 装载键值（获取键值）</li>\n<li>Store(): 储存键值</li>\n<li>Delete(): 删除键值</li>\n<li>LoadOrStore(): 如果存在则获取键值，不存在则存储</li>\n<li>Range(): 遍历 Map</li>\n</ul>\n<p>我在项目中使用该类型替代了自己原本定义的一个全局 Map 类型，相比自己维护互斥锁或者读写锁等操作方便了不少，而且性能有优势（具体没有测试），据官方说明该 Map 类型显著减少了锁的争用。</p>\n<h3 id=\"Mutex\"><a href=\"#Mutex\" class=\"headerlink\" title=\"Mutex\"></a>Mutex</h3><p>互斥锁。对于加了锁的操作，其他的 Goroutine 在读取相应对象时会阻塞，知道互斥对象释放。频繁、大量的使用互斥锁会导致性能的降低，应该只在必须用的地方用。互斥锁使用不当还有可能造成死锁、活锁、饿死等情况，就比较复杂了。</p>\n<h3 id=\"RWMutex\"><a href=\"#RWMutex\" class=\"headerlink\" title=\"RWMutex\"></a>RWMutex</h3><p>读写锁。相较互斥锁，读写锁相较互斥锁性能损耗低些，因为对于只读操作只加共享锁，是支持并发的，仅在写操作上加互斥锁，明显提升了效率。</p>\n<h3 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h3><p>Once 这个对象很有用，它是一个只执行一个操作的对象。该对象仅有一个 Do() 方法，仅当 Once 实例第一次调用 Do() 方法时，Do() 才会调用传递过来的函数。</p>\n<p>这对于要实现单例模式的代码会方便一些，定义一个 Once 对象，将要实现单例的对象的初始化方法传递给 Do()，就能保证单例的并发安全。</p>\n<p>但使用互斥锁不也能解决这个问题吗？其实不然，互斥锁的代价太高，会导致 Goroutines 无法对该变量进行并发访问。那我把它改成读写锁呢？例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mu sync.RWMutex // 定义读写锁</span><br><span class=\"line\">var someMap map[string]interface&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 并发安全的单例</span><br><span class=\"line\">func GetMap(name string) interface&#123;&#125; &#123;</span><br><span class=\"line\">    // 加读锁，并判断 someMap 是否为空</span><br><span class=\"line\">    // 如果不为空则获取 Map 中的值</span><br><span class=\"line\">    mu.RLock()</span><br><span class=\"line\">    if someMap != nil &#123;</span><br><span class=\"line\">        foo := someMap[name]</span><br><span class=\"line\">        mu.RUnlock()</span><br><span class=\"line\">        return foo</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 注意这里无法在 else 语句将共享锁升级为互斥锁</span><br><span class=\"line\">    mu.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果 someMap 为空加互斥锁，并初始化 someMap</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    // 注意：必须要再一次检查是否为 nil</span><br><span class=\"line\">    if someMap == nil &#123; </span><br><span class=\"line\">        CreateMap()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    foo := someMap[name]</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">    return foo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然而这种方式不觉得太复杂了吗？</p>\n<h1 id=\"Pool\"><a href=\"#Pool\" class=\"headerlink\" title=\"Pool\"></a>Pool</h1><p>Pool 是一组用来保存或者检索的临时对象。Pub() 方法的入参是空接口，意味着可以把任何类型的对象放置在池子中以复用，减轻垃圾回收器的压力，正确的使用能很轻松的构建高效、线程安全的自由列表。</p>\n<h1 id=\"WaitGroup\"><a href=\"#WaitGroup\" class=\"headerlink\" title=\"WaitGroup\"></a>WaitGroup</h1><p>WaitGroup 适用于等待多个 Goroutine 完成的逻辑下使用，控制多个 Goroutine 之间的同步。每新建一个 Goroutine 就可以调用 WaitGroup.Add() 来增加需要等待的 Goroutine 数量，当每个 Goroutine 都运行完毕时各自调用 Done() ，可以在程序的外层调用 Wait() 以阻塞程序直到所有 Goroutine 都调用了 Done()。</p>\n<p>这样就可以在程序中使每个 WaitGroup 之间是同步的，但是 WaitGroup 之内的 Goroutine 是异步的。</p>\n<h1 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h1><p>与 WaitGroup 不同，Context 实现了对串行的 Goroutine 的跟踪和控制，比如一个 Goroutine 在运行过程中派生出了其他 Goroutine，这些派生出的 Goroutine 又派生出了其他 Goroutine，这种 Goroutine 的关系链使用之前的 Channel + Select 来维护会使得程序变得异常复杂。而使用 Context 上下文来实现 Goroutine 间截止时间、取消信号或其他变量的共享和传递会变得简单。</p>\n<p>Context 有四种方法来派生出不同的上下文：</p>\n<ul>\n<li>WithCancel: 传递取消信号</li>\n<li>WithDeadline: 传递截止时间</li>\n<li>WithTimeout: 传递超时信号</li>\n<li>WithValue: 传递其他值</li>\n</ul>\n<p>例如 WithCancel 派生出的上下文，在对应 Goroutine 中调用 cancel() 会使所有同一上下文派生出的所有 Goroutine 关闭，在派生出的 Goroutine 中可以通过监听 ctx.Done() 来判断是否关闭 Goroutine。</p>\n<p>Context 还有许多其他的用途，在 gRPC 、gin 中大量运用了 Context。Context 是并发安全的，所以可以放心的在 Goroutines 之间传递。</p>\n<p>在Golang并发编程中，内存泄露和一些注意事项是需要特别关注的，以下是常见的情况和建议：</p>\n<h1 id=\"常见内存泄露及注意事项\"><a href=\"#常见内存泄露及注意事项\" class=\"headerlink\" title=\"常见内存泄露及注意事项\"></a>常见内存泄露及注意事项</h1><ol>\n<li><p><strong>goroutine泄露</strong></p>\n<ul>\n<li><strong>场景</strong>：goroutine因阻塞（如未关闭的channel、死循环）无法退出，导致内存泄露。每个goroutine占用2KB内存，大量goroutine泄露会造成内存占用持续增加。</li>\n<li><strong>原因</strong>：goroutine在执行时被阻塞而无法退出，如未关闭的channel导致接收方一直等待。</li>\n<li><strong>避免</strong>：确保goroutine有明确的退出机制，如使用<code>context.Context</code>传递取消信号，关闭channel通知协程退出。</li>\n</ul>\n</li>\n<li><p><strong>time.Ticker未关闭</strong></p>\n<ul>\n<li><strong>场景</strong>：time.Ticker每间隔指定时间向通道写数据，若不调用<code>Stop()</code>方法，会一直占用内存。</li>\n<li><strong>避免</strong>：在使用完time.Ticker后，务必调用<code>Stop()</code>方法来停止它。</li>\n</ul>\n</li>\n<li><p><strong>字符串和切片截取</strong></p>\n<ul>\n<li><strong>场景</strong>：长字符串或切片被截取后，如果截取的小部分还在活跃，原大块内存将无法被回收，导致临时内存泄露。</li>\n<li><strong>避免</strong>：在不需要保留原大块内存时，可以复制需要的部分到新的变量，或者使用其他方式避免共享底层数组。</li>\n</ul>\n</li>\n<li><p><strong>Finalizer导致泄漏</strong></p>\n<ul>\n<li><strong>场景</strong>：设置Finalizer后，对象的内存无法被垃圾回收器及时回收，尤其当存在循环引用时。</li>\n<li><strong>避免</strong>：谨慎使用Finalizer，避免不必要的循环引用。</li>\n</ul>\n</li>\n<li><p><strong>Deferring Function Call导致泄漏</strong></p>\n<ul>\n<li><strong>场景</strong>：大量文件打开后仅在函数结束时释放，造成临时内存泄露。</li>\n<li><strong>避免</strong>：在循环中打开文件时，应立即关闭，而不是等待函数结束。</li>\n</ul>\n</li>\n<li><p><strong>内存分配未释放</strong></p>\n<ul>\n<li><strong>场景</strong>：持续分配内存但未释放，如持续向切片中添加数据而未清理。</li>\n<li><strong>避免</strong>：合理管理内存分配和释放，避免不必要的内存堆积。</li>\n</ul>\n</li>\n<li><p><strong>大数组作为参数</strong></p>\n<ul>\n<li><strong>场景</strong>：大数组作为形参时，值拷贝导致内存使用激增。</li>\n<li><strong>避免</strong>：对于大数组，使用切片或指针传递，减少内存占用。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"注意事项-2\"><a href=\"#注意事项-2\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ol>\n<li><p><strong>并发安全与同步</strong></p>\n<ul>\n<li>共享资源需用<code>sync.Mutex</code>、<code>sync.RWMutex</code>或原子操作保护，优先使用Channel传递数据，避免直接共享内存。</li>\n</ul>\n</li>\n<li><p><strong>控制并发量</strong></p>\n<ul>\n<li>避免无限制创建协程，使用带缓冲的Channel、Worker Pool或信号量限制并发数。</li>\n</ul>\n</li>\n<li><p><strong>处理协程错误</strong></p>\n<ul>\n<li>在goroutine内部使用<code>defer</code>+<code>recover</code>处理<code>panic</code>，避免整个程序崩溃。</li>\n</ul>\n</li>\n<li><p><strong>避免Channel死锁</strong></p>\n<ul>\n<li>确保Channel的发送和接收成对出现，避免协程永久阻塞，如未关闭的Channel可能导致接收方等待。</li>\n</ul>\n</li>\n<li><p><strong>利用Context传递元数据和取消信号</strong></p>\n<ul>\n<li>使用<code>context.Context</code>传递元数据和取消信号，方便控制goroutine的生命周期。</li>\n</ul>\n</li>\n<li><p><strong>合理使用锁</strong></p>\n<ul>\n<li>避免在持有锁的情况下调用可能导致阻塞的操作，如I&#x2F;O操作，防止死锁。</li>\n</ul>\n</li>\n<li><p><strong>监控和分析</strong></p>\n<ul>\n<li>使用<code>runtime.MemStats</code>监控内存使用情况，使用<code>pprof</code>进行性能分析，及时发现和解决内存和性能问题。</li>\n</ul>\n</li>\n</ol>\n<p>通过遵循以上建议和注意事项，可以有效避免Golang并发编程中的内存泄露问题，编写出高效、稳定的并发程序。</p>\n"},{"title":"币圈学习-衍生品系列01","date":"2025-04-28T08:46:06.000Z","_content":"\n# 币圈-衍生品系列\n\n## 0、前言-衍生品的定义与特点\n\n衍生品是一种金融合约，其价值基于基础资产（如加密货币、股票、商品等）的价格波动。它具有**杠杆性**、**高风险性**和**高收益性**的特点。杠杆性使得投资者能用少量资金控制较大规模的资产；高风险性源于市场波动的不确定性，微小的价格变动在杠杆作用下可能引发巨大损失；高收益性则为投资者提供了以小博大的机会。此外，衍生品还具备**跨期性**，交易双方通过对未来价格走势的预期达成合约，以及**联动性**，其价格紧密跟随基础资产的变化。\n\n## 1、什么是合约\n\n传统的期货合约和虚拟货币中的合约中概念上是相同的，他们都是一种衍生品，允许两方之后约定中未来某个时间以特定价格买入或卖出某种资产的合约。\n\n## 2、什么是永续合约\n\n永续合约是一种没有到期日的期货合约，它通过资金费率机制使合约价格与标的资产价格保持联动。其特点包括：\n\n- **无到期日**：投资者无需担心合约到期交割问题，可长期持有头寸。\n\n- **资金费率机制**：调节市场多空双方的持仓成本，使合约价格贴近标的资产现货价格。\n\n- **杠杆交易**：允许投资者使用杠杆放大收益，但同时也增加了风险。\n\n永续合约与期货合约的区别​\n\n- **到期日**：期货合约有固定到期日，永续合约无到期日。\n\n- **交割方式**：期货合约到期进行实物或现金交割，永续合约不进行交割。\n\n- **价格机制**：期货合约价格受到期日、市场预期等因素影响，与现货价格可能存在较大偏差；永续合约通过资金费率机制，使合约价格与现货价格紧密相连。\n\n### 2.1 资金费率含义和作用\n\n资金费率是永续合约特有的机制，用于调节合约价格与现货价格的偏差。计算公式为：资金费率=溢价指数加权平均值+利率溢价。\n\n其中，溢价指数反映合约价格与现货价格的偏离程度，利率溢价考虑资金的时间价值。不同交易所的具体计算方式可能略有差异。\n\n具体来说：\n\n- **市场供需**：当市场多头需求旺盛，合约价格高于现货价格时，资金费率为正，多头需向空头支付资金费用；反之，当空头需求旺盛，合约价格低于现货价格时，资金费率为负，空头需向多头支付资金费用。\n\n- **利率水平**：市场利率水平的变化会影响资金费率中的利率溢价部分。一般来说，利率上升，资金费率中的利率溢价部分增加。\n\n- **市场情绪**：投资者对市场的乐观或悲观情绪会影响多空双方的持仓意愿，进而影响资金费率。\n\n作用：\n\n>  资金费率反映了市场多空双方的力量对比和对未来价格走势的预期。正资金费率表明多头力量较强，市场看涨情绪浓厚；负资金费率则表示空头力量占优，市场看跌情绪明显。资金费率的作用在于通过调节持仓成本，促使合约价格向现货价格回归，减少市场的不合理溢价或折价，维护市场的稳定和公平。\n\n### 2.2 资金费率套利\n\n1. 资金费率套利的原理与策略​\n\n资金费率套利的原理是利用资金费率的正负差异，在多空双方之间进行套利操作。当资金费率为正时，多头持仓成本增加，空头持仓成本降低。此时，投资者可以卖出永续合约（做空），同时在现货市场买入标的资产，通过收取资金费用和现货价格上涨获取收益。当资金费率为负时，操作相反，买入永续合约（做多），同时在现货市场卖空标的资产。\n\n2. 套利机会的识别与风险评估​\n\n识别套利机会需要实时监测资金费率的变化、合约价格与现货价格的差异以及市场流动性等因素。当资金费率偏离正常范围，且市场流动性充足时，可能存在套利机会。风险评估方面，主要面临**价格波动风险**，在套利过程中，标的资产价格的不利波动可能导致套利失败；**市场流动性风险**，若市场流动性不足，可能无法及时开仓或平仓；**交易所风险**，如交易所故障、资金结算问题等也会影响套利操作。\n\n### 2.3 什么是合约中的杠杆\n\n杠杆原理是通过借入资金，放大投资者的交易头寸。例如，使用 10 倍杠杆，投资者只需支付 10% 的保证金，就能控制 10 倍价值的合约。杠杆倍数的选择需综合考虑投资者的风险承受能力、市场波动情况和交易策略。高杠杆倍数在放大收益的同时，也会大幅增加损失风险，适合风险偏好较高、对市场走势判断准确的投资者；低杠杆倍数风险相对较低，适合稳健型投资者。\n\n杠杆交易的收益和风险呈线性放大关系。以 10 倍杠杆为例，若投资者判断正确，标的资产价格上涨 10%，不考虑手续费等因素，投资者的收益为 100%；但如果判断错误，价格下跌 10%，投资者将损失全部保证金。此外，杠杆交易还可能面临**追加保证金风险**，当账户权益低于维持保证金要求时，投资者需及时追加保证金，否则将被强制平仓，导致更大损失。\n\n### 2.4 什么是保证金\n\n保证金是投资者在进行合约交易时，存入交易账户的资金，用于保证交易的履约。\n\n- **初始保证金**：开仓时所需缴纳的保证金，通常为合约价值的一定比例（如 5% - 20%）。\n\n- **维持保证金**：持仓过程中，为保证合约不被强制平仓，账户权益需维持的最低保证金水平，一般低于初始保证金。\n\n#### 2.4.1 平仓\n\n- **平仓的概念与操作方式**：平仓是指投资者了结持仓的交易行为，通过反向操作（如买入开仓后卖出平仓，卖出开仓后买入平仓）结束合约头寸。操作方式可在交易平台上直接点击平仓按钮，选择平仓数量和价格进行操作。\n\n- **平仓时机的选择与策略**：平仓时机的选择取决于投资者的交易策略和市场情况。对于短线交易者，可根据技术指标信号（如均线交叉、MACD 背离等）选择平仓；对于套期保值者，当达到预期的风险对冲效果或市场情况发生变化时平仓；对于套利者，在套利利润达到预期或套利机会消失时平仓。\n\n#### 2.4.2 爆仓\n\n- **爆仓的定义与触发条件**：爆仓是指当投资者账户权益低于维持保证金要求，且未及时追加保证金或减仓时，交易所为防止损失扩大，对其持仓进行强制平仓的情况。触发条件为账户权益跌破维持保证金水平。\n\n- **爆仓的风险与后果**：爆仓会导致投资者损失全部保证金，甚至可能因市场极端行情，导致账户出现负资产，需要额外偿还债务。此外，爆仓还会对投资者的心理造成打击，影响后续交易决策。\n\n- **避免爆仓的策略与方法**：合理控制仓位，避免过度使用杠杆；设置止损位，当价格达到止损价格时自动平仓，限制损失；密切关注市场动态，及时调整交易策略；保持充足的资金储备，以便在需要时追加保证金。\n\n## 3、主要的加密货币衍生品类型简介​\n\n- **期货合约**：买卖双方约定在未来某一特定时间，以特定价格买入或卖出一定数量加密货币的合约。\n\n- **期权合约**：赋予买方在规定期限内按双方约定的执行价格，购买或出售一定数量加密货币的权利。\n\n- **永续合约**：没有到期日的期货合约，通过资金费率机制使合约价格贴近标的资产价格。\n\n- **期权期货组合衍生品**：结合期货和期权的特性，为投资者提供更灵活的风险对冲和收益获取方式。\n\n## 4、合约交易中的选项\n\n3.1 什么是 u 本位，什么是 b 本位\n\n3.2 什么是被动委托\n\n3.3 什么是止盈止损\n\n3.4 什么是冰山委托\n\n3.5 什么是只减仓\n\n\n# 加餐\n\n## 为什么说空军是燃料\n\n基于上面的资金费机制，当市场上出现一种小币种高度拉盘现象，比如 xxx 币，这种底部只有几百万市值的盘子，庄可以很低成本控紧流通的现货筹码。\n\n具体来说：\n\n- 拉盘前只需要建个巨大的合约多单，然后开拉现货，只要散户对手盘的空单需求仓位大幅超过多单仓位，根据资金费机制，市场上就会持续扣空军的资金费给到庄。\n- 庄拿到这部分的资金费率去买现货，现货就会带着合约价格往上走，每爆一个空军仓位就会转化为合约的新的实盘，之前开的合约多头仓位就会越赚越多，收到的资金费也越来越多，也就意味着能来拉盘现货的资金也就越来越多。\n- 出现这种情况的需要有个必要前提：一个控筹紧的现货盘和无限的空军，理论上有了这两个条件，可以拉出一个过亿，甚至万亿市场\n\n上面这段话里有个前提：那就是当空单需求大于多单的时候，就会出现期货价格低于现货价格，资金费率变负的情况，所以只要庄的多单仓位小于市场提供的空单需求，资金费率就会持续往庄那走。\n\n更进一步\n\n>  做市商是流动性提供者，会盯着散户的出牌走反向操作打掉散户止损再回去，反复收割。\n>\n> 合约市场基本是对手盘。","source":"_posts/币圈学习-衍生品系列01.md","raw":"---\ntitle: 币圈学习-衍生品系列01\ndate: 2025-04-28 16:46:06\ntags: 币圈\n---\n\n# 币圈-衍生品系列\n\n## 0、前言-衍生品的定义与特点\n\n衍生品是一种金融合约，其价值基于基础资产（如加密货币、股票、商品等）的价格波动。它具有**杠杆性**、**高风险性**和**高收益性**的特点。杠杆性使得投资者能用少量资金控制较大规模的资产；高风险性源于市场波动的不确定性，微小的价格变动在杠杆作用下可能引发巨大损失；高收益性则为投资者提供了以小博大的机会。此外，衍生品还具备**跨期性**，交易双方通过对未来价格走势的预期达成合约，以及**联动性**，其价格紧密跟随基础资产的变化。\n\n## 1、什么是合约\n\n传统的期货合约和虚拟货币中的合约中概念上是相同的，他们都是一种衍生品，允许两方之后约定中未来某个时间以特定价格买入或卖出某种资产的合约。\n\n## 2、什么是永续合约\n\n永续合约是一种没有到期日的期货合约，它通过资金费率机制使合约价格与标的资产价格保持联动。其特点包括：\n\n- **无到期日**：投资者无需担心合约到期交割问题，可长期持有头寸。\n\n- **资金费率机制**：调节市场多空双方的持仓成本，使合约价格贴近标的资产现货价格。\n\n- **杠杆交易**：允许投资者使用杠杆放大收益，但同时也增加了风险。\n\n永续合约与期货合约的区别​\n\n- **到期日**：期货合约有固定到期日，永续合约无到期日。\n\n- **交割方式**：期货合约到期进行实物或现金交割，永续合约不进行交割。\n\n- **价格机制**：期货合约价格受到期日、市场预期等因素影响，与现货价格可能存在较大偏差；永续合约通过资金费率机制，使合约价格与现货价格紧密相连。\n\n### 2.1 资金费率含义和作用\n\n资金费率是永续合约特有的机制，用于调节合约价格与现货价格的偏差。计算公式为：资金费率=溢价指数加权平均值+利率溢价。\n\n其中，溢价指数反映合约价格与现货价格的偏离程度，利率溢价考虑资金的时间价值。不同交易所的具体计算方式可能略有差异。\n\n具体来说：\n\n- **市场供需**：当市场多头需求旺盛，合约价格高于现货价格时，资金费率为正，多头需向空头支付资金费用；反之，当空头需求旺盛，合约价格低于现货价格时，资金费率为负，空头需向多头支付资金费用。\n\n- **利率水平**：市场利率水平的变化会影响资金费率中的利率溢价部分。一般来说，利率上升，资金费率中的利率溢价部分增加。\n\n- **市场情绪**：投资者对市场的乐观或悲观情绪会影响多空双方的持仓意愿，进而影响资金费率。\n\n作用：\n\n>  资金费率反映了市场多空双方的力量对比和对未来价格走势的预期。正资金费率表明多头力量较强，市场看涨情绪浓厚；负资金费率则表示空头力量占优，市场看跌情绪明显。资金费率的作用在于通过调节持仓成本，促使合约价格向现货价格回归，减少市场的不合理溢价或折价，维护市场的稳定和公平。\n\n### 2.2 资金费率套利\n\n1. 资金费率套利的原理与策略​\n\n资金费率套利的原理是利用资金费率的正负差异，在多空双方之间进行套利操作。当资金费率为正时，多头持仓成本增加，空头持仓成本降低。此时，投资者可以卖出永续合约（做空），同时在现货市场买入标的资产，通过收取资金费用和现货价格上涨获取收益。当资金费率为负时，操作相反，买入永续合约（做多），同时在现货市场卖空标的资产。\n\n2. 套利机会的识别与风险评估​\n\n识别套利机会需要实时监测资金费率的变化、合约价格与现货价格的差异以及市场流动性等因素。当资金费率偏离正常范围，且市场流动性充足时，可能存在套利机会。风险评估方面，主要面临**价格波动风险**，在套利过程中，标的资产价格的不利波动可能导致套利失败；**市场流动性风险**，若市场流动性不足，可能无法及时开仓或平仓；**交易所风险**，如交易所故障、资金结算问题等也会影响套利操作。\n\n### 2.3 什么是合约中的杠杆\n\n杠杆原理是通过借入资金，放大投资者的交易头寸。例如，使用 10 倍杠杆，投资者只需支付 10% 的保证金，就能控制 10 倍价值的合约。杠杆倍数的选择需综合考虑投资者的风险承受能力、市场波动情况和交易策略。高杠杆倍数在放大收益的同时，也会大幅增加损失风险，适合风险偏好较高、对市场走势判断准确的投资者；低杠杆倍数风险相对较低，适合稳健型投资者。\n\n杠杆交易的收益和风险呈线性放大关系。以 10 倍杠杆为例，若投资者判断正确，标的资产价格上涨 10%，不考虑手续费等因素，投资者的收益为 100%；但如果判断错误，价格下跌 10%，投资者将损失全部保证金。此外，杠杆交易还可能面临**追加保证金风险**，当账户权益低于维持保证金要求时，投资者需及时追加保证金，否则将被强制平仓，导致更大损失。\n\n### 2.4 什么是保证金\n\n保证金是投资者在进行合约交易时，存入交易账户的资金，用于保证交易的履约。\n\n- **初始保证金**：开仓时所需缴纳的保证金，通常为合约价值的一定比例（如 5% - 20%）。\n\n- **维持保证金**：持仓过程中，为保证合约不被强制平仓，账户权益需维持的最低保证金水平，一般低于初始保证金。\n\n#### 2.4.1 平仓\n\n- **平仓的概念与操作方式**：平仓是指投资者了结持仓的交易行为，通过反向操作（如买入开仓后卖出平仓，卖出开仓后买入平仓）结束合约头寸。操作方式可在交易平台上直接点击平仓按钮，选择平仓数量和价格进行操作。\n\n- **平仓时机的选择与策略**：平仓时机的选择取决于投资者的交易策略和市场情况。对于短线交易者，可根据技术指标信号（如均线交叉、MACD 背离等）选择平仓；对于套期保值者，当达到预期的风险对冲效果或市场情况发生变化时平仓；对于套利者，在套利利润达到预期或套利机会消失时平仓。\n\n#### 2.4.2 爆仓\n\n- **爆仓的定义与触发条件**：爆仓是指当投资者账户权益低于维持保证金要求，且未及时追加保证金或减仓时，交易所为防止损失扩大，对其持仓进行强制平仓的情况。触发条件为账户权益跌破维持保证金水平。\n\n- **爆仓的风险与后果**：爆仓会导致投资者损失全部保证金，甚至可能因市场极端行情，导致账户出现负资产，需要额外偿还债务。此外，爆仓还会对投资者的心理造成打击，影响后续交易决策。\n\n- **避免爆仓的策略与方法**：合理控制仓位，避免过度使用杠杆；设置止损位，当价格达到止损价格时自动平仓，限制损失；密切关注市场动态，及时调整交易策略；保持充足的资金储备，以便在需要时追加保证金。\n\n## 3、主要的加密货币衍生品类型简介​\n\n- **期货合约**：买卖双方约定在未来某一特定时间，以特定价格买入或卖出一定数量加密货币的合约。\n\n- **期权合约**：赋予买方在规定期限内按双方约定的执行价格，购买或出售一定数量加密货币的权利。\n\n- **永续合约**：没有到期日的期货合约，通过资金费率机制使合约价格贴近标的资产价格。\n\n- **期权期货组合衍生品**：结合期货和期权的特性，为投资者提供更灵活的风险对冲和收益获取方式。\n\n## 4、合约交易中的选项\n\n3.1 什么是 u 本位，什么是 b 本位\n\n3.2 什么是被动委托\n\n3.3 什么是止盈止损\n\n3.4 什么是冰山委托\n\n3.5 什么是只减仓\n\n\n# 加餐\n\n## 为什么说空军是燃料\n\n基于上面的资金费机制，当市场上出现一种小币种高度拉盘现象，比如 xxx 币，这种底部只有几百万市值的盘子，庄可以很低成本控紧流通的现货筹码。\n\n具体来说：\n\n- 拉盘前只需要建个巨大的合约多单，然后开拉现货，只要散户对手盘的空单需求仓位大幅超过多单仓位，根据资金费机制，市场上就会持续扣空军的资金费给到庄。\n- 庄拿到这部分的资金费率去买现货，现货就会带着合约价格往上走，每爆一个空军仓位就会转化为合约的新的实盘，之前开的合约多头仓位就会越赚越多，收到的资金费也越来越多，也就意味着能来拉盘现货的资金也就越来越多。\n- 出现这种情况的需要有个必要前提：一个控筹紧的现货盘和无限的空军，理论上有了这两个条件，可以拉出一个过亿，甚至万亿市场\n\n上面这段话里有个前提：那就是当空单需求大于多单的时候，就会出现期货价格低于现货价格，资金费率变负的情况，所以只要庄的多单仓位小于市场提供的空单需求，资金费率就会持续往庄那走。\n\n更进一步\n\n>  做市商是流动性提供者，会盯着散户的出牌走反向操作打掉散户止损再回去，反复收割。\n>\n> 合约市场基本是对手盘。","slug":"币圈学习-衍生品系列01","published":1,"updated":"2025-04-28T08:47:11.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cma0u51t30000wytfhgj36col","content":"<h1 id=\"币圈-衍生品系列\"><a href=\"#币圈-衍生品系列\" class=\"headerlink\" title=\"币圈-衍生品系列\"></a>币圈-衍生品系列</h1><h2 id=\"0、前言-衍生品的定义与特点\"><a href=\"#0、前言-衍生品的定义与特点\" class=\"headerlink\" title=\"0、前言-衍生品的定义与特点\"></a>0、前言-衍生品的定义与特点</h2><p>衍生品是一种金融合约，其价值基于基础资产（如加密货币、股票、商品等）的价格波动。它具有<strong>杠杆性</strong>、<strong>高风险性</strong>和<strong>高收益性</strong>的特点。杠杆性使得投资者能用少量资金控制较大规模的资产；高风险性源于市场波动的不确定性，微小的价格变动在杠杆作用下可能引发巨大损失；高收益性则为投资者提供了以小博大的机会。此外，衍生品还具备<strong>跨期性</strong>，交易双方通过对未来价格走势的预期达成合约，以及<strong>联动性</strong>，其价格紧密跟随基础资产的变化。</p>\n<h2 id=\"1、什么是合约\"><a href=\"#1、什么是合约\" class=\"headerlink\" title=\"1、什么是合约\"></a>1、什么是合约</h2><p>传统的期货合约和虚拟货币中的合约中概念上是相同的，他们都是一种衍生品，允许两方之后约定中未来某个时间以特定价格买入或卖出某种资产的合约。</p>\n<h2 id=\"2、什么是永续合约\"><a href=\"#2、什么是永续合约\" class=\"headerlink\" title=\"2、什么是永续合约\"></a>2、什么是永续合约</h2><p>永续合约是一种没有到期日的期货合约，它通过资金费率机制使合约价格与标的资产价格保持联动。其特点包括：</p>\n<ul>\n<li><p><strong>无到期日</strong>：投资者无需担心合约到期交割问题，可长期持有头寸。</p>\n</li>\n<li><p><strong>资金费率机制</strong>：调节市场多空双方的持仓成本，使合约价格贴近标的资产现货价格。</p>\n</li>\n<li><p><strong>杠杆交易</strong>：允许投资者使用杠杆放大收益，但同时也增加了风险。</p>\n</li>\n</ul>\n<p>永续合约与期货合约的区别​</p>\n<ul>\n<li><p><strong>到期日</strong>：期货合约有固定到期日，永续合约无到期日。</p>\n</li>\n<li><p><strong>交割方式</strong>：期货合约到期进行实物或现金交割，永续合约不进行交割。</p>\n</li>\n<li><p><strong>价格机制</strong>：期货合约价格受到期日、市场预期等因素影响，与现货价格可能存在较大偏差；永续合约通过资金费率机制，使合约价格与现货价格紧密相连。</p>\n</li>\n</ul>\n<h3 id=\"2-1-资金费率含义和作用\"><a href=\"#2-1-资金费率含义和作用\" class=\"headerlink\" title=\"2.1 资金费率含义和作用\"></a>2.1 资金费率含义和作用</h3><p>资金费率是永续合约特有的机制，用于调节合约价格与现货价格的偏差。计算公式为：资金费率&#x3D;溢价指数加权平均值+利率溢价。</p>\n<p>其中，溢价指数反映合约价格与现货价格的偏离程度，利率溢价考虑资金的时间价值。不同交易所的具体计算方式可能略有差异。</p>\n<p>具体来说：</p>\n<ul>\n<li><p><strong>市场供需</strong>：当市场多头需求旺盛，合约价格高于现货价格时，资金费率为正，多头需向空头支付资金费用；反之，当空头需求旺盛，合约价格低于现货价格时，资金费率为负，空头需向多头支付资金费用。</p>\n</li>\n<li><p><strong>利率水平</strong>：市场利率水平的变化会影响资金费率中的利率溢价部分。一般来说，利率上升，资金费率中的利率溢价部分增加。</p>\n</li>\n<li><p><strong>市场情绪</strong>：投资者对市场的乐观或悲观情绪会影响多空双方的持仓意愿，进而影响资金费率。</p>\n</li>\n</ul>\n<p>作用：</p>\n<blockquote>\n<p> 资金费率反映了市场多空双方的力量对比和对未来价格走势的预期。正资金费率表明多头力量较强，市场看涨情绪浓厚；负资金费率则表示空头力量占优，市场看跌情绪明显。资金费率的作用在于通过调节持仓成本，促使合约价格向现货价格回归，减少市场的不合理溢价或折价，维护市场的稳定和公平。</p>\n</blockquote>\n<h3 id=\"2-2-资金费率套利\"><a href=\"#2-2-资金费率套利\" class=\"headerlink\" title=\"2.2 资金费率套利\"></a>2.2 资金费率套利</h3><ol>\n<li>资金费率套利的原理与策略​</li>\n</ol>\n<p>资金费率套利的原理是利用资金费率的正负差异，在多空双方之间进行套利操作。当资金费率为正时，多头持仓成本增加，空头持仓成本降低。此时，投资者可以卖出永续合约（做空），同时在现货市场买入标的资产，通过收取资金费用和现货价格上涨获取收益。当资金费率为负时，操作相反，买入永续合约（做多），同时在现货市场卖空标的资产。</p>\n<ol start=\"2\">\n<li>套利机会的识别与风险评估​</li>\n</ol>\n<p>识别套利机会需要实时监测资金费率的变化、合约价格与现货价格的差异以及市场流动性等因素。当资金费率偏离正常范围，且市场流动性充足时，可能存在套利机会。风险评估方面，主要面临<strong>价格波动风险</strong>，在套利过程中，标的资产价格的不利波动可能导致套利失败；<strong>市场流动性风险</strong>，若市场流动性不足，可能无法及时开仓或平仓；<strong>交易所风险</strong>，如交易所故障、资金结算问题等也会影响套利操作。</p>\n<h3 id=\"2-3-什么是合约中的杠杆\"><a href=\"#2-3-什么是合约中的杠杆\" class=\"headerlink\" title=\"2.3 什么是合约中的杠杆\"></a>2.3 什么是合约中的杠杆</h3><p>杠杆原理是通过借入资金，放大投资者的交易头寸。例如，使用 10 倍杠杆，投资者只需支付 10% 的保证金，就能控制 10 倍价值的合约。杠杆倍数的选择需综合考虑投资者的风险承受能力、市场波动情况和交易策略。高杠杆倍数在放大收益的同时，也会大幅增加损失风险，适合风险偏好较高、对市场走势判断准确的投资者；低杠杆倍数风险相对较低，适合稳健型投资者。</p>\n<p>杠杆交易的收益和风险呈线性放大关系。以 10 倍杠杆为例，若投资者判断正确，标的资产价格上涨 10%，不考虑手续费等因素，投资者的收益为 100%；但如果判断错误，价格下跌 10%，投资者将损失全部保证金。此外，杠杆交易还可能面临<strong>追加保证金风险</strong>，当账户权益低于维持保证金要求时，投资者需及时追加保证金，否则将被强制平仓，导致更大损失。</p>\n<h3 id=\"2-4-什么是保证金\"><a href=\"#2-4-什么是保证金\" class=\"headerlink\" title=\"2.4 什么是保证金\"></a>2.4 什么是保证金</h3><p>保证金是投资者在进行合约交易时，存入交易账户的资金，用于保证交易的履约。</p>\n<ul>\n<li><p><strong>初始保证金</strong>：开仓时所需缴纳的保证金，通常为合约价值的一定比例（如 5% - 20%）。</p>\n</li>\n<li><p><strong>维持保证金</strong>：持仓过程中，为保证合约不被强制平仓，账户权益需维持的最低保证金水平，一般低于初始保证金。</p>\n</li>\n</ul>\n<h4 id=\"2-4-1-平仓\"><a href=\"#2-4-1-平仓\" class=\"headerlink\" title=\"2.4.1 平仓\"></a>2.4.1 平仓</h4><ul>\n<li><p><strong>平仓的概念与操作方式</strong>：平仓是指投资者了结持仓的交易行为，通过反向操作（如买入开仓后卖出平仓，卖出开仓后买入平仓）结束合约头寸。操作方式可在交易平台上直接点击平仓按钮，选择平仓数量和价格进行操作。</p>\n</li>\n<li><p><strong>平仓时机的选择与策略</strong>：平仓时机的选择取决于投资者的交易策略和市场情况。对于短线交易者，可根据技术指标信号（如均线交叉、MACD 背离等）选择平仓；对于套期保值者，当达到预期的风险对冲效果或市场情况发生变化时平仓；对于套利者，在套利利润达到预期或套利机会消失时平仓。</p>\n</li>\n</ul>\n<h4 id=\"2-4-2-爆仓\"><a href=\"#2-4-2-爆仓\" class=\"headerlink\" title=\"2.4.2 爆仓\"></a>2.4.2 爆仓</h4><ul>\n<li><p><strong>爆仓的定义与触发条件</strong>：爆仓是指当投资者账户权益低于维持保证金要求，且未及时追加保证金或减仓时，交易所为防止损失扩大，对其持仓进行强制平仓的情况。触发条件为账户权益跌破维持保证金水平。</p>\n</li>\n<li><p><strong>爆仓的风险与后果</strong>：爆仓会导致投资者损失全部保证金，甚至可能因市场极端行情，导致账户出现负资产，需要额外偿还债务。此外，爆仓还会对投资者的心理造成打击，影响后续交易决策。</p>\n</li>\n<li><p><strong>避免爆仓的策略与方法</strong>：合理控制仓位，避免过度使用杠杆；设置止损位，当价格达到止损价格时自动平仓，限制损失；密切关注市场动态，及时调整交易策略；保持充足的资金储备，以便在需要时追加保证金。</p>\n</li>\n</ul>\n<h2 id=\"3、主要的加密货币衍生品类型简介​\"><a href=\"#3、主要的加密货币衍生品类型简介​\" class=\"headerlink\" title=\"3、主要的加密货币衍生品类型简介​\"></a>3、主要的加密货币衍生品类型简介​</h2><ul>\n<li><p><strong>期货合约</strong>：买卖双方约定在未来某一特定时间，以特定价格买入或卖出一定数量加密货币的合约。</p>\n</li>\n<li><p><strong>期权合约</strong>：赋予买方在规定期限内按双方约定的执行价格，购买或出售一定数量加密货币的权利。</p>\n</li>\n<li><p><strong>永续合约</strong>：没有到期日的期货合约，通过资金费率机制使合约价格贴近标的资产价格。</p>\n</li>\n<li><p><strong>期权期货组合衍生品</strong>：结合期货和期权的特性，为投资者提供更灵活的风险对冲和收益获取方式。</p>\n</li>\n</ul>\n<h2 id=\"4、合约交易中的选项\"><a href=\"#4、合约交易中的选项\" class=\"headerlink\" title=\"4、合约交易中的选项\"></a>4、合约交易中的选项</h2><p>3.1 什么是 u 本位，什么是 b 本位</p>\n<p>3.2 什么是被动委托</p>\n<p>3.3 什么是止盈止损</p>\n<p>3.4 什么是冰山委托</p>\n<p>3.5 什么是只减仓</p>\n<h1 id=\"加餐\"><a href=\"#加餐\" class=\"headerlink\" title=\"加餐\"></a>加餐</h1><h2 id=\"为什么说空军是燃料\"><a href=\"#为什么说空军是燃料\" class=\"headerlink\" title=\"为什么说空军是燃料\"></a>为什么说空军是燃料</h2><p>基于上面的资金费机制，当市场上出现一种小币种高度拉盘现象，比如 xxx 币，这种底部只有几百万市值的盘子，庄可以很低成本控紧流通的现货筹码。</p>\n<p>具体来说：</p>\n<ul>\n<li>拉盘前只需要建个巨大的合约多单，然后开拉现货，只要散户对手盘的空单需求仓位大幅超过多单仓位，根据资金费机制，市场上就会持续扣空军的资金费给到庄。</li>\n<li>庄拿到这部分的资金费率去买现货，现货就会带着合约价格往上走，每爆一个空军仓位就会转化为合约的新的实盘，之前开的合约多头仓位就会越赚越多，收到的资金费也越来越多，也就意味着能来拉盘现货的资金也就越来越多。</li>\n<li>出现这种情况的需要有个必要前提：一个控筹紧的现货盘和无限的空军，理论上有了这两个条件，可以拉出一个过亿，甚至万亿市场</li>\n</ul>\n<p>上面这段话里有个前提：那就是当空单需求大于多单的时候，就会出现期货价格低于现货价格，资金费率变负的情况，所以只要庄的多单仓位小于市场提供的空单需求，资金费率就会持续往庄那走。</p>\n<p>更进一步</p>\n<blockquote>\n<p> 做市商是流动性提供者，会盯着散户的出牌走反向操作打掉散户止损再回去，反复收割。</p>\n<p>合约市场基本是对手盘。</p>\n</blockquote>\n","site":{"data":{"languages":{"zh-Hans":{"site":{"title":"herongweiの博客"}}}}},"excerpt":"","more":"<h1 id=\"币圈-衍生品系列\"><a href=\"#币圈-衍生品系列\" class=\"headerlink\" title=\"币圈-衍生品系列\"></a>币圈-衍生品系列</h1><h2 id=\"0、前言-衍生品的定义与特点\"><a href=\"#0、前言-衍生品的定义与特点\" class=\"headerlink\" title=\"0、前言-衍生品的定义与特点\"></a>0、前言-衍生品的定义与特点</h2><p>衍生品是一种金融合约，其价值基于基础资产（如加密货币、股票、商品等）的价格波动。它具有<strong>杠杆性</strong>、<strong>高风险性</strong>和<strong>高收益性</strong>的特点。杠杆性使得投资者能用少量资金控制较大规模的资产；高风险性源于市场波动的不确定性，微小的价格变动在杠杆作用下可能引发巨大损失；高收益性则为投资者提供了以小博大的机会。此外，衍生品还具备<strong>跨期性</strong>，交易双方通过对未来价格走势的预期达成合约，以及<strong>联动性</strong>，其价格紧密跟随基础资产的变化。</p>\n<h2 id=\"1、什么是合约\"><a href=\"#1、什么是合约\" class=\"headerlink\" title=\"1、什么是合约\"></a>1、什么是合约</h2><p>传统的期货合约和虚拟货币中的合约中概念上是相同的，他们都是一种衍生品，允许两方之后约定中未来某个时间以特定价格买入或卖出某种资产的合约。</p>\n<h2 id=\"2、什么是永续合约\"><a href=\"#2、什么是永续合约\" class=\"headerlink\" title=\"2、什么是永续合约\"></a>2、什么是永续合约</h2><p>永续合约是一种没有到期日的期货合约，它通过资金费率机制使合约价格与标的资产价格保持联动。其特点包括：</p>\n<ul>\n<li><p><strong>无到期日</strong>：投资者无需担心合约到期交割问题，可长期持有头寸。</p>\n</li>\n<li><p><strong>资金费率机制</strong>：调节市场多空双方的持仓成本，使合约价格贴近标的资产现货价格。</p>\n</li>\n<li><p><strong>杠杆交易</strong>：允许投资者使用杠杆放大收益，但同时也增加了风险。</p>\n</li>\n</ul>\n<p>永续合约与期货合约的区别​</p>\n<ul>\n<li><p><strong>到期日</strong>：期货合约有固定到期日，永续合约无到期日。</p>\n</li>\n<li><p><strong>交割方式</strong>：期货合约到期进行实物或现金交割，永续合约不进行交割。</p>\n</li>\n<li><p><strong>价格机制</strong>：期货合约价格受到期日、市场预期等因素影响，与现货价格可能存在较大偏差；永续合约通过资金费率机制，使合约价格与现货价格紧密相连。</p>\n</li>\n</ul>\n<h3 id=\"2-1-资金费率含义和作用\"><a href=\"#2-1-资金费率含义和作用\" class=\"headerlink\" title=\"2.1 资金费率含义和作用\"></a>2.1 资金费率含义和作用</h3><p>资金费率是永续合约特有的机制，用于调节合约价格与现货价格的偏差。计算公式为：资金费率&#x3D;溢价指数加权平均值+利率溢价。</p>\n<p>其中，溢价指数反映合约价格与现货价格的偏离程度，利率溢价考虑资金的时间价值。不同交易所的具体计算方式可能略有差异。</p>\n<p>具体来说：</p>\n<ul>\n<li><p><strong>市场供需</strong>：当市场多头需求旺盛，合约价格高于现货价格时，资金费率为正，多头需向空头支付资金费用；反之，当空头需求旺盛，合约价格低于现货价格时，资金费率为负，空头需向多头支付资金费用。</p>\n</li>\n<li><p><strong>利率水平</strong>：市场利率水平的变化会影响资金费率中的利率溢价部分。一般来说，利率上升，资金费率中的利率溢价部分增加。</p>\n</li>\n<li><p><strong>市场情绪</strong>：投资者对市场的乐观或悲观情绪会影响多空双方的持仓意愿，进而影响资金费率。</p>\n</li>\n</ul>\n<p>作用：</p>\n<blockquote>\n<p> 资金费率反映了市场多空双方的力量对比和对未来价格走势的预期。正资金费率表明多头力量较强，市场看涨情绪浓厚；负资金费率则表示空头力量占优，市场看跌情绪明显。资金费率的作用在于通过调节持仓成本，促使合约价格向现货价格回归，减少市场的不合理溢价或折价，维护市场的稳定和公平。</p>\n</blockquote>\n<h3 id=\"2-2-资金费率套利\"><a href=\"#2-2-资金费率套利\" class=\"headerlink\" title=\"2.2 资金费率套利\"></a>2.2 资金费率套利</h3><ol>\n<li>资金费率套利的原理与策略​</li>\n</ol>\n<p>资金费率套利的原理是利用资金费率的正负差异，在多空双方之间进行套利操作。当资金费率为正时，多头持仓成本增加，空头持仓成本降低。此时，投资者可以卖出永续合约（做空），同时在现货市场买入标的资产，通过收取资金费用和现货价格上涨获取收益。当资金费率为负时，操作相反，买入永续合约（做多），同时在现货市场卖空标的资产。</p>\n<ol start=\"2\">\n<li>套利机会的识别与风险评估​</li>\n</ol>\n<p>识别套利机会需要实时监测资金费率的变化、合约价格与现货价格的差异以及市场流动性等因素。当资金费率偏离正常范围，且市场流动性充足时，可能存在套利机会。风险评估方面，主要面临<strong>价格波动风险</strong>，在套利过程中，标的资产价格的不利波动可能导致套利失败；<strong>市场流动性风险</strong>，若市场流动性不足，可能无法及时开仓或平仓；<strong>交易所风险</strong>，如交易所故障、资金结算问题等也会影响套利操作。</p>\n<h3 id=\"2-3-什么是合约中的杠杆\"><a href=\"#2-3-什么是合约中的杠杆\" class=\"headerlink\" title=\"2.3 什么是合约中的杠杆\"></a>2.3 什么是合约中的杠杆</h3><p>杠杆原理是通过借入资金，放大投资者的交易头寸。例如，使用 10 倍杠杆，投资者只需支付 10% 的保证金，就能控制 10 倍价值的合约。杠杆倍数的选择需综合考虑投资者的风险承受能力、市场波动情况和交易策略。高杠杆倍数在放大收益的同时，也会大幅增加损失风险，适合风险偏好较高、对市场走势判断准确的投资者；低杠杆倍数风险相对较低，适合稳健型投资者。</p>\n<p>杠杆交易的收益和风险呈线性放大关系。以 10 倍杠杆为例，若投资者判断正确，标的资产价格上涨 10%，不考虑手续费等因素，投资者的收益为 100%；但如果判断错误，价格下跌 10%，投资者将损失全部保证金。此外，杠杆交易还可能面临<strong>追加保证金风险</strong>，当账户权益低于维持保证金要求时，投资者需及时追加保证金，否则将被强制平仓，导致更大损失。</p>\n<h3 id=\"2-4-什么是保证金\"><a href=\"#2-4-什么是保证金\" class=\"headerlink\" title=\"2.4 什么是保证金\"></a>2.4 什么是保证金</h3><p>保证金是投资者在进行合约交易时，存入交易账户的资金，用于保证交易的履约。</p>\n<ul>\n<li><p><strong>初始保证金</strong>：开仓时所需缴纳的保证金，通常为合约价值的一定比例（如 5% - 20%）。</p>\n</li>\n<li><p><strong>维持保证金</strong>：持仓过程中，为保证合约不被强制平仓，账户权益需维持的最低保证金水平，一般低于初始保证金。</p>\n</li>\n</ul>\n<h4 id=\"2-4-1-平仓\"><a href=\"#2-4-1-平仓\" class=\"headerlink\" title=\"2.4.1 平仓\"></a>2.4.1 平仓</h4><ul>\n<li><p><strong>平仓的概念与操作方式</strong>：平仓是指投资者了结持仓的交易行为，通过反向操作（如买入开仓后卖出平仓，卖出开仓后买入平仓）结束合约头寸。操作方式可在交易平台上直接点击平仓按钮，选择平仓数量和价格进行操作。</p>\n</li>\n<li><p><strong>平仓时机的选择与策略</strong>：平仓时机的选择取决于投资者的交易策略和市场情况。对于短线交易者，可根据技术指标信号（如均线交叉、MACD 背离等）选择平仓；对于套期保值者，当达到预期的风险对冲效果或市场情况发生变化时平仓；对于套利者，在套利利润达到预期或套利机会消失时平仓。</p>\n</li>\n</ul>\n<h4 id=\"2-4-2-爆仓\"><a href=\"#2-4-2-爆仓\" class=\"headerlink\" title=\"2.4.2 爆仓\"></a>2.4.2 爆仓</h4><ul>\n<li><p><strong>爆仓的定义与触发条件</strong>：爆仓是指当投资者账户权益低于维持保证金要求，且未及时追加保证金或减仓时，交易所为防止损失扩大，对其持仓进行强制平仓的情况。触发条件为账户权益跌破维持保证金水平。</p>\n</li>\n<li><p><strong>爆仓的风险与后果</strong>：爆仓会导致投资者损失全部保证金，甚至可能因市场极端行情，导致账户出现负资产，需要额外偿还债务。此外，爆仓还会对投资者的心理造成打击，影响后续交易决策。</p>\n</li>\n<li><p><strong>避免爆仓的策略与方法</strong>：合理控制仓位，避免过度使用杠杆；设置止损位，当价格达到止损价格时自动平仓，限制损失；密切关注市场动态，及时调整交易策略；保持充足的资金储备，以便在需要时追加保证金。</p>\n</li>\n</ul>\n<h2 id=\"3、主要的加密货币衍生品类型简介​\"><a href=\"#3、主要的加密货币衍生品类型简介​\" class=\"headerlink\" title=\"3、主要的加密货币衍生品类型简介​\"></a>3、主要的加密货币衍生品类型简介​</h2><ul>\n<li><p><strong>期货合约</strong>：买卖双方约定在未来某一特定时间，以特定价格买入或卖出一定数量加密货币的合约。</p>\n</li>\n<li><p><strong>期权合约</strong>：赋予买方在规定期限内按双方约定的执行价格，购买或出售一定数量加密货币的权利。</p>\n</li>\n<li><p><strong>永续合约</strong>：没有到期日的期货合约，通过资金费率机制使合约价格贴近标的资产价格。</p>\n</li>\n<li><p><strong>期权期货组合衍生品</strong>：结合期货和期权的特性，为投资者提供更灵活的风险对冲和收益获取方式。</p>\n</li>\n</ul>\n<h2 id=\"4、合约交易中的选项\"><a href=\"#4、合约交易中的选项\" class=\"headerlink\" title=\"4、合约交易中的选项\"></a>4、合约交易中的选项</h2><p>3.1 什么是 u 本位，什么是 b 本位</p>\n<p>3.2 什么是被动委托</p>\n<p>3.3 什么是止盈止损</p>\n<p>3.4 什么是冰山委托</p>\n<p>3.5 什么是只减仓</p>\n<h1 id=\"加餐\"><a href=\"#加餐\" class=\"headerlink\" title=\"加餐\"></a>加餐</h1><h2 id=\"为什么说空军是燃料\"><a href=\"#为什么说空军是燃料\" class=\"headerlink\" title=\"为什么说空军是燃料\"></a>为什么说空军是燃料</h2><p>基于上面的资金费机制，当市场上出现一种小币种高度拉盘现象，比如 xxx 币，这种底部只有几百万市值的盘子，庄可以很低成本控紧流通的现货筹码。</p>\n<p>具体来说：</p>\n<ul>\n<li>拉盘前只需要建个巨大的合约多单，然后开拉现货，只要散户对手盘的空单需求仓位大幅超过多单仓位，根据资金费机制，市场上就会持续扣空军的资金费给到庄。</li>\n<li>庄拿到这部分的资金费率去买现货，现货就会带着合约价格往上走，每爆一个空军仓位就会转化为合约的新的实盘，之前开的合约多头仓位就会越赚越多，收到的资金费也越来越多，也就意味着能来拉盘现货的资金也就越来越多。</li>\n<li>出现这种情况的需要有个必要前提：一个控筹紧的现货盘和无限的空军，理论上有了这两个条件，可以拉出一个过亿，甚至万亿市场</li>\n</ul>\n<p>上面这段话里有个前提：那就是当空单需求大于多单的时候，就会出现期货价格低于现货价格，资金费率变负的情况，所以只要庄的多单仓位小于市场提供的空单需求，资金费率就会持续往庄那走。</p>\n<p>更进一步</p>\n<blockquote>\n<p> 做市商是流动性提供者，会盯着散户的出牌走反向操作打掉散户止损再回去，反复收割。</p>\n<p>合约市场基本是对手盘。</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm8mvlblj0001a06cd4aa3nei","category_id":"cm8mvlbll0004a06cabr8avx3","_id":"cm8mvlblm0009a06c8muhckc3"},{"post_id":"cm8mvlblk0003a06cewof913k","category_id":"cm8mvlblm0007a06cgryc7s7p","_id":"cm8mvlblm000ba06cdvw1h38v"},{"post_id":"clgp9kd4i00007xn9gypl6efa","category_id":"cm8mvlblm000aa06c4uh4ambt","_id":"cm8mvlblm000ca06cfh8s3e8z"},{"post_id":"cm8mwrp8r00005f6cddys5m20","category_id":"cm8mvlblm000aa06c4uh4ambt","_id":"cm8mwrp8t00025f6c65kq7q5j"},{"post_id":"cm8sidd1a0000un6c6qo7a6z1","category_id":"cm8mvlblm000aa06c4uh4ambt","_id":"cm8sidd1d0002un6c5rox1ixz"}],"PostTag":[{"post_id":"cm8mvlblj0001a06cd4aa3nei","tag_id":"cm8mvlbll0005a06cgt1l9zy9","_id":"cm8mvlblm0008a06c5lhfaw97"},{"post_id":"cm8mwrp8r00005f6cddys5m20","tag_id":"cm8mwrp8t00015f6cajjp8hf8","_id":"cm8mwrp8t00035f6ch0uoc6f4"},{"post_id":"cm8sidd1a0000un6c6qo7a6z1","tag_id":"cm8sidd1c0001un6c5ee66t88","_id":"cm8sidd1d0003un6c5uhmbjuv"},{"post_id":"cma0u51t30000wytfhgj36col","tag_id":"cma0u51t50001wytf1jch2mo8","_id":"cma0u51t60002wytf0ifla6ua"}],"Tag":[{"name":"总结","_id":"cm8mvlbll0005a06cgt1l9zy9"},{"name":"rust","_id":"cm8mwrp8t00015f6cajjp8hf8"},{"name":"golang","_id":"cm8sidd1c0001un6c5ee66t88"},{"name":"币圈","_id":"cma0u51t50001wytf1jch2mo8"}]}}